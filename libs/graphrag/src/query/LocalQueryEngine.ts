/**
 * LocalQueryEngine
 *
 * Implements local search strategy for GraphRAG queries.
 * Retrieves entities and relations from the knowledge graph
 * based on semantic similarity and graph traversal.
 */

import type { RelationType } from '@yagokoro/domain';
import {
  DEFAULT_LOCAL_OPTIONS,
  type EntityRetriever,
  type LocalQueryOptions,
  type QueryContext,
  type QueryEntity,
  type QueryMetrics,
  type QueryRelation,
  type QueryResponse,
  type VectorSearcher,
} from './types.js';

/**
 * Dependencies for LocalQueryEngine
 */
export interface LocalQueryEngineDeps {
  /** Entity retriever for graph traversal */
  entityRetriever: EntityRetriever;
  /** Vector searcher for semantic search */
  vectorSearcher: VectorSearcher;
  /** Function to fetch relations between entities */
  relationFetcher: (entityIds: string[]) => Promise<QueryRelation[]>;
}

/**
 * Local Query Engine
 *
 * Performs local search in the knowledge graph by:
 * 1. Finding seed entities via vector similarity search
 * 2. Expanding to neighbors via graph traversal
 * 3. Fetching relations between retrieved entities
 * 4. Building context for response generation
 *
 * @example
 * ```typescript
 * const engine = new LocalQueryEngine({
 *   entityRetriever,
 *   vectorSearcher,
 *   relationFetcher,
 * });
 *
 * const result = await engine.query('What is GPT-4?');
 * console.log(result.context.entities);
 * ```
 */
export class LocalQueryEngine {
  private readonly deps: LocalQueryEngineDeps;
  private readonly options: Required<LocalQueryOptions>;

  constructor(deps: LocalQueryEngineDeps, options: LocalQueryOptions = {}) {
    this.deps = deps;
    this.options = { ...DEFAULT_LOCAL_OPTIONS, ...options };
  }

  /**
   * Execute a local query
   *
   * @param queryText - Natural language query
   * @param options - Override default options for this query
   * @returns Query response with context
   */
  async query(
    queryText: string,
    options?: LocalQueryOptions
  ): Promise<QueryResponse> {
    const mergedOptions = { ...this.options, ...options };
    const startTime = performance.now();
    const retrievalStart = startTime;

    const metrics: QueryMetrics = {
      totalTimeMs: 0,
      retrievalTimeMs: 0,
      generationTimeMs: 0,
      entitiesRetrieved: 0,
      relationsRetrieved: 0,
      communitiesConsulted: 0,
    };

    try {
      // Step 1: Vector search for seed entities
      const seedEntities = await this.deps.vectorSearcher.search(
        queryText,
        mergedOptions.maxEntities,
        mergedOptions.minSimilarity
      );

      // Step 2: Expand to neighbors if hop depth > 0
      const expandedEntities = await this.expandNeighbors(
        seedEntities,
        mergedOptions.hopDepth
      );

      // Step 3: Deduplicate and filter entities
      const uniqueEntities = this.deduplicateEntities([
        ...seedEntities,
        ...expandedEntities,
      ]);

      // Filter by minimum similarity
      const filteredEntities = uniqueEntities.filter(
        (e) => e.relevance >= mergedOptions.minSimilarity
      );

      // Limit to maxEntities
      const limitedEntities = filteredEntities
        .sort((a, b) => b.relevance - a.relevance)
        .slice(0, mergedOptions.maxEntities);

      metrics.retrievalTimeMs = performance.now() - retrievalStart;
      metrics.entitiesRetrieved = limitedEntities.length;

      // Step 4: Fetch relations between entities
      const entityIds = limitedEntities.map((e) => e.id);
      const relations = await this.deps.relationFetcher(entityIds);
      metrics.relationsRetrieved = relations.length;

      // Step 5: Build context
      const context = this.buildContext(limitedEntities, relations);

      metrics.totalTimeMs = performance.now() - startTime;

      return {
        query: queryText,
        answer: '', // Answer is generated by ResponseGenerator
        queryType: 'local',
        citations: this.buildCitations(limitedEntities),
        context,
        metrics,
        success: true,
      };
    } catch (error) {
      metrics.totalTimeMs = performance.now() - startTime;
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';

      return {
        query: queryText,
        answer: '',
        queryType: 'local',
        citations: [],
        context: this.emptyContext(),
        metrics,
        success: false,
        error: `Local query failed: ${errorMessage}`,
      };
    }
  }

  /**
   * Expand seed entities to their neighbors
   */
  private async expandNeighbors(
    seedEntities: QueryEntity[],
    hopDepth: number
  ): Promise<QueryEntity[]> {
    if (hopDepth === 0 || seedEntities.length === 0) {
      return [];
    }

    const neighbors: QueryEntity[] = [];
    const visited = new Set(seedEntities.map((e) => e.id));

    // BFS expansion
    let currentLevel = seedEntities;

    for (let depth = 0; depth < hopDepth; depth++) {
      const nextLevel: QueryEntity[] = [];

      for (const entity of currentLevel) {
        const entityNeighbors = await this.deps.entityRetriever.retrieveNeighbors(
          entity.id,
          1
        );

        for (const neighbor of entityNeighbors) {
          if (!visited.has(neighbor.id)) {
            visited.add(neighbor.id);
            // Decay relevance with depth
            neighbor.relevance *= Math.pow(0.8, depth + 1);
            nextLevel.push(neighbor);
            neighbors.push(neighbor);
          }
        }
      }

      currentLevel = nextLevel;

      if (currentLevel.length === 0) {
        break;
      }
    }

    return neighbors;
  }

  /**
   * Deduplicate entities by ID
   */
  private deduplicateEntities(entities: QueryEntity[]): QueryEntity[] {
    const seen = new Map<string, QueryEntity>();

    for (const entity of entities) {
      const existing = seen.get(entity.id);
      if (!existing || entity.relevance > existing.relevance) {
        seen.set(entity.id, entity);
      }
    }

    return Array.from(seen.values());
  }

  /**
   * Build query context from entities and relations
   */
  private buildContext(
    entities: QueryEntity[],
    relations: QueryRelation[]
  ): QueryContext {
    // Generate text chunks from entity descriptions
    const textChunks: string[] = [];

    for (const entity of entities) {
      if (entity.description) {
        textChunks.push(`${entity.name}: ${entity.description}`);
      }
    }

    // Add relation descriptions
    for (const relation of relations) {
      textChunks.push(
        `${relation.sourceName} ${this.formatRelationType(relation.type)} ${relation.targetName}`
      );
    }

    return {
      entities,
      relations,
      communitySummaries: [],
      textChunks,
    };
  }

  /**
   * Build citations from entities
   */
  private buildCitations(entities: QueryEntity[]) {
    return entities.map((entity) => {
      const citation: {
        entityId: string;
        entityName: string;
        sourceType: 'entity';
        relevance: number;
        excerpt?: string;
      } = {
        entityId: entity.id,
        entityName: entity.name,
        sourceType: 'entity' as const,
        relevance: entity.relevance,
      };
      if (entity.description !== undefined) {
        citation.excerpt = entity.description;
      }
      return citation;
    });
  }

  /**
   * Format relation type for display
   */
  private formatRelationType(type: RelationType): string {
    return type.toLowerCase().replace(/_/g, ' ');
  }

  /**
   * Create empty context
   */
  private emptyContext(): QueryContext {
    return {
      entities: [],
      relations: [],
      communitySummaries: [],
      textChunks: [],
    };
  }
}

/**
 * HybridSearchEngine
 *
 * Combines local and global search strategies for comprehensive
 * query results. Uses weighted combination of entity-level and
 * community-level insights.
 */

import {
  type Citation,
  type QueryCommunitySummary,
  type HybridQueryOptions,
  type QueryContext,
  type QueryEntity,
  type QueryMetrics,
  type QueryResponse,
} from './types.js';

/**
 * Default hybrid options
 */
const DEFAULT_HYBRID_OPTIONS: Required<
  Pick<HybridQueryOptions, 'localWeight' | 'globalWeight' | 'searchMode'>
> = {
  localWeight: 0.6,
  globalWeight: 0.4,
  searchMode: 'hybrid',
};

/**
 * Dependencies for HybridSearchEngine
 */
export interface HybridSearchEngineDeps {
  /** Local query function */
  localQuery: (query: string) => Promise<QueryResponse>;
  /** Global query function */
  globalQuery: (query: string) => Promise<QueryResponse>;
}

/**
 * Hybrid Search Engine
 *
 * Combines local (entity-focused) and global (community-focused) search
 * strategies for comprehensive knowledge retrieval.
 *
 * Local search excels at:
 * - Specific entity queries
 * - Relationship lookups
 * - Detailed information
 *
 * Global search excels at:
 * - Broad topic overviews
 * - Theme identification
 * - High-level summaries
 *
 * The hybrid approach provides:
 * - Specific details when available
 * - Broader context for understanding
 * - Weighted combination of results
 *
 * @example
 * ```typescript
 * const engine = new HybridSearchEngine({
 *   localQuery: (q) => localEngine.query(q),
 *   globalQuery: (q) => globalEngine.query(q),
 * });
 *
 * const result = await engine.search('What is GPT-4?');
 * // Gets both specific GPT-4 info and broader AI model context
 * ```
 */
export class HybridSearchEngine {
  private readonly deps: HybridSearchEngineDeps;
  private readonly options: Required<
    Pick<HybridQueryOptions, 'localWeight' | 'globalWeight' | 'searchMode'>
  >;

  constructor(
    deps: HybridSearchEngineDeps,
    options?: Pick<HybridQueryOptions, 'localWeight' | 'globalWeight' | 'searchMode'>
  ) {
    this.deps = deps;
    this.options = { ...DEFAULT_HYBRID_OPTIONS, ...options };
  }

  /**
   * Execute hybrid search
   *
   * @param queryText - Natural language query
   * @param options - Override default options for this query
   * @returns Combined query response
   */
  async search(
    queryText: string,
    options?: Pick<HybridQueryOptions, 'localWeight' | 'globalWeight' | 'searchMode'>
  ): Promise<QueryResponse> {
    const mergedOptions = { ...this.options, ...options };
    const startTime = performance.now();

    try {
      // Run local and global queries in parallel
      const [localResult, globalResult] = await Promise.allSettled([
        this.deps.localQuery(queryText),
        this.deps.globalQuery(queryText),
      ]);

      // Extract results (may be rejected or unsuccessful)
      const local =
        localResult.status === 'fulfilled' && localResult.value.success
          ? localResult.value
          : null;

      const global =
        globalResult.status === 'fulfilled' && globalResult.value.success
          ? globalResult.value
          : null;

      // If both failed, return error
      if (!local && !global) {
        return this.createErrorResponse(
          queryText,
          'Both local and global searches failed',
          startTime
        );
      }

      // Combine results
      const combinedContext = this.combineContext(
        local?.context,
        global?.context,
        mergedOptions.localWeight,
        mergedOptions.globalWeight
      );

      const combinedCitations = this.combineCitations(
        local?.citations || [],
        global?.citations || []
      );

      const combinedMetrics = this.combineMetrics(
        local?.metrics,
        global?.metrics,
        startTime
      );

      return {
        query: queryText,
        answer: '', // Answer is generated by ResponseGenerator
        queryType: 'hybrid',
        citations: combinedCitations,
        context: combinedContext,
        metrics: combinedMetrics,
        success: true,
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      return this.createErrorResponse(
        queryText,
        `Hybrid search failed: ${errorMessage}`,
        startTime
      );
    }
  }

  /**
   * Combine contexts from local and global searches
   */
  private combineContext(
    local: QueryContext | undefined,
    global: QueryContext | undefined,
    localWeight: number,
    globalWeight: number
  ): QueryContext {
    // Apply weights to entity relevance
    const entities: QueryEntity[] = (local?.entities || []).map((e) => ({
      ...e,
      relevance: e.relevance * localWeight,
    }));

    // Apply weights to community relevance
    const communitySummaries: QueryCommunitySummary[] = (global?.communitySummaries || []).map(
      (c) => ({
        ...c,
        relevance: c.relevance * globalWeight,
      })
    );

    // Combine text chunks
    const textChunks = [
      ...(local?.textChunks || []),
      ...(global?.textChunks || []),
    ];

    return {
      entities,
      relations: local?.relations || [],
      communitySummaries,
      textChunks,
    };
  }

  /**
   * Combine citations from both sources
   */
  private combineCitations(
    localCitations: Citation[],
    globalCitations: Citation[]
  ): Citation[] {
    // Combine and sort by relevance
    return [...localCitations, ...globalCitations].sort(
      (a, b) => b.relevance - a.relevance
    );
  }

  /**
   * Combine metrics from both engines
   */
  private combineMetrics(
    local: QueryMetrics | undefined,
    global: QueryMetrics | undefined,
    startTime: number
  ): QueryMetrics {
    const totalTimeMs = performance.now() - startTime;

    return {
      totalTimeMs,
      retrievalTimeMs:
        (local?.retrievalTimeMs || 0) + (global?.retrievalTimeMs || 0),
      generationTimeMs:
        (local?.generationTimeMs || 0) + (global?.generationTimeMs || 0),
      entitiesRetrieved: local?.entitiesRetrieved || 0,
      relationsRetrieved: local?.relationsRetrieved || 0,
      communitiesConsulted: global?.communitiesConsulted || 0,
    };
  }

  /**
   * Create error response
   */
  private createErrorResponse(
    query: string,
    error: string,
    startTime: number
  ): QueryResponse {
    return {
      query,
      answer: '',
      queryType: 'hybrid',
      citations: [],
      context: {
        entities: [],
        relations: [],
        communitySummaries: [],
        textChunks: [],
      },
      metrics: {
        totalTimeMs: performance.now() - startTime,
        retrievalTimeMs: 0,
        generationTimeMs: 0,
        entitiesRetrieved: 0,
        relationsRetrieved: 0,
        communitiesConsulted: 0,
      },
      success: false,
      error,
    };
  }
}

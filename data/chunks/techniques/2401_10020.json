{
  "paper": {
    "id": "2401.10020v3",
    "title": "Self-Rewarding Language Models",
    "abstract": "We posit that to achieve superhuman agents, future models require superhuman feedback in order to provide an adequate training signal. Current approaches commonly train reward models from human preferences, which may then be bottlenecked by human performance level, and secondly these separate frozen reward models cannot then learn to improve during LLM training. In this work, we study Self-Rewarding Language Models, where the language model itself is used via LLM-as-a-Judge prompting to provide its own rewards during training. We show that during Iterative DPO training that not only does instruction following ability improve, but also the ability to provide high-quality rewards to itself. Fine-tuning Llama 2 70B on three iterations of our approach yields a model that outperforms many existing systems on the AlpacaEval 2.0 leaderboard, including Claude 2, Gemini Pro, and GPT-4 0613. While there is much left still to explore, this work opens the door to the possibility of models that can continually improve in both axes.",
    "authors": [
      "Weizhe Yuan",
      "Richard Yuanzhe Pang",
      "Kyunghyun Cho",
      "Xian Li",
      "Sainbayar Sukhbaatar",
      "Jing Xu",
      "Jason Weston"
    ],
    "published": "2024-01-18T14:43:47.000Z",
    "updated": "2025-03-28T00:06:51.000Z",
    "primaryCategory": "cs.CL",
    "categories": [
      "cs.CL",
      "cs.AI"
    ],
    "pdfUrl": "https://arxiv.org/pdf/2401.10020v3",
    "absUrl": "https://arxiv.org/abs/2401.10020v3"
  },
  "chunks": [
    {
      "id": "2401.10020v3-chunk-0",
      "content": "Weizhe Yuan 1 , 2 Richard Yuanzhe Pang 1 , 2 Kyunghyun Cho 2 Xian Li 1 Sainbayar Sukhbaatar 1 Jing Xu 1 Jason Weston 1 , 2\n\n1 Meta\n\n2 NYU",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "Self-Rewarding Language Models",
        "chunkIndex": 0,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-1",
      "content": "We posit that to achieve superhuman agents, future models require superhuman feedback in order to provide an adequate training signal. Current approaches commonly train reward models from human preferences, which may then be bottlenecked by human performance level, and secondly these separate frozen reward models cannot then learn to improve during LLM training. In this work, we study Self-Rewarding Language Models , where the language model itself is used via LLM-as-a-Judge prompting to provide its own rewards during training. We show that during Iterative DPO training that not only does instruction following ability improve, but also the ability to provide high-quality rewards to itself. Fine-tuning Llama 2 70B on three iterations of our approach yields a model that outperforms many existing systems on the AlpacaEval 2.0 leaderboard, including Claude 2, Gemini Pro, and GPT-4 0613.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "Abstract",
        "chunkIndex": 1,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-2",
      "content": "lf. Fine-tuning Llama 2 70B on three iterations of our approach yields a model that outperforms many existing systems on the AlpacaEval 2.0 leaderboard, including Claude 2, Gemini Pro, and GPT-4 0613. While there is much left still to explore, this work opens the door to the possibility of models that can continually improve in both axes.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "Abstract",
        "chunkIndex": 2,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-3",
      "content": "Aligning Large Language Models (LLMs) using human preference data can vastly improve the instruction following performance of pretrained models [Ouyang et al., 2022, Bai et al., 2022a]. The standard approach of Reinforcement Learning from Human Feedback (RLHF) learns a reward model from these human preferences. The reward model is then frozen and used to train the LLM using RL, e.g., via PPO [Schulman et al., 2017]. A recent alternative is to avoid training the reward model at all, and directly use human preferences to train the LLM, as in Direct Preference Optimization [DPO; Rafailov et al., 2023]. In both cases, the approach is bottlenecked by the size and quality of the human preference data, and in the case of RLHF the quality of the frozen reward model trained from them as well.\n\nIn this work, we instead propose to train a self-improving reward model that, rather than being frozen, is continually updating during LLM alignment, in order to avoid this bottleneck.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "1 Introduction",
        "chunkIndex": 3,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-4",
      "content": "them as well.\n\nIn this work, we instead propose to train a self-improving reward model that, rather than being frozen, is continually updating during LLM alignment, in order to avoid this bottleneck. The key to such an approach is to develop an agent that possesses all the abilities desired during training, rather than separating them out into distinct models such as a reward model and a language model. In the same way that pretraining and multitasking training of instruction following tasks allow task transfer by training on many tasks at once [Collobert and Weston, 2008, Radford et al., 2019, Ouyang et al., 2022], incorporating the reward model into that same system allows task transfer between the reward modeling task and the instruction following tasks.\n\nWe thus introduce Self-Rewarding Language Models , that both (i) act as instruction following models generating responses for given prompts; and (ii) can generate and evaluate new instruction following examples to add to their own",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "1 Introduction",
        "chunkIndex": 4,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-5",
      "content": "ng Language Models , that both (i) act as instruction following models generating responses for given prompts; and (ii) can generate and evaluate new instruction following examples to add to their own training set. We train these models using an Iterative DPO framework similar to that recently introduced in Xu et al. [2023].\n\nFigure 1: Self-Rewarding Language Models. Our self-alignment method consists of two steps: (i) Self-Instruction creation : newly created prompts are used to generate candidate responses from model M t , which also predicts its own rewards via LLM-as-a-Judge prompting. (ii) Instruction following training : preference pairs are selected from the generated data, which are used for training via DPO, resulting in model M t +1 . This whole procedure can then be iterated resulting in both improved instruction following and reward modeling ability.\n\n<!-- image -->",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "1 Introduction",
        "chunkIndex": 5,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-6",
      "content": "which are used for training via DPO, resulting in model M t +1 . This whole procedure can then be iterated resulting in both improved instruction following and reward modeling ability.\n\n<!-- image -->\n\nStarting from a seed model, in each iteration there is a process of Self-Instruction creation whereby candidate responses are generated by the model for newly created prompts, and are then assigned rewards by that same model. The latter is implemented via LLM-as-a-Judge prompting, which can also be seen as an instruction following task. A preference dataset is built from the generated data, and the next iteration of the model is trained via DPO, see Figure 1.\n\nIn our experiments, we start with a Llama 2 70B [Touvron et al., 2023] seed model fine-tuned on Open Assistant [Köpf et al., 2023], and then perform the above training scheme.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "1 Introduction",
        "chunkIndex": 6,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-7",
      "content": "via DPO, see Figure 1.\n\nIn our experiments, we start with a Llama 2 70B [Touvron et al., 2023] seed model fine-tuned on Open Assistant [Köpf et al., 2023], and then perform the above training scheme. We find that not only does the instruction following performance improve from Self-Rewarding LLM alignment compared to the baseline seed model, but importantly the reward modeling ability, which is no longer fixed, improves as well. This means that the model during iterative training is able, at a given iteration, to provide a higher quality preference dataset to itself than in the previous iteration. While this effect likely saturates in real-world settings, it provides the intriguing possibility of obtaining reward models (and hence LLMs) that are superior to ones that could have been trained from the original human-authored seed data alone.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "1 Introduction",
        "chunkIndex": 7,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-8",
      "content": "Our approach first assumes access to a base pretrained language model, and a small amount of human-annotated seed data. We then build a model that aims to possess two skills simultaneously:\n\n1. Instruction following : given a prompt that describes a user request, the ability to generate a high quality, helpful (and harmless) response.\n2. Self-Instruction creation : the ability to generate and evaluate new instructionfollowing examples to add to its own training set.\n\nThese skills are used so that the model can perform self-alignment, i.e., they are the components used to iteratively train itself using AI Feedback (AIF).\n\nSelf-instruction creation consists of generating candidate responses and then the model itself judging their quality, i.e., it acts as its own reward model, replacing the need for an external one. This is implemented via the LLM-as-a-Judge mechanism [Zheng et al., 2023b], i.e., by formulating the evaluation of responses as an instruction following task.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "2 Self-Rewarding Language Models",
        "chunkIndex": 8,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-9",
      "content": ", replacing the need for an external one. This is implemented via the LLM-as-a-Judge mechanism [Zheng et al., 2023b], i.e., by formulating the evaluation of responses as an instruction following task. This self-created AIF preference data is used as a training set.\n\nOur overall self-alignment procedure is an iterative one, which proceeds by building a series of such models, with the aim that each improves over the last. Importantly, because the model can both improve its generation ability, and act as its own reward model through the same generation mechanism, this means the reward model itself can improve through these iterations, deviating from standard practices where the reward model is fixed [Ouyang et al.,\n\n2022]. We believe this can increase the ceiling of the potential for self-improvement of these learning models going forward, removing a constraining bottleneck.\n\nWe describe these steps in more detail below. An overview of the approach is illustrated in Figure 1.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "2 Self-Rewarding Language Models",
        "chunkIndex": 9,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-10",
      "content": "rovement of these learning models going forward, removing a constraining bottleneck.\n\nWe describe these steps in more detail below. An overview of the approach is illustrated in Figure 1.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "2 Self-Rewarding Language Models",
        "chunkIndex": 10,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-11",
      "content": "Seed instruction following data We are given a seed set of human-authored (instruction prompt, response) general instruction following examples that we use for training in a supervised fine-tuning (SFT) manner, starting from a pretrained base language model. Subsequently this will be referred to as Instruction Fine-Tuning (IFT) data.\n\nSeed LLM-as-a-Judge instruction following data We also assume we are provided a seed set of (evaluation instruction prompt, evaluation result response) examples which can also be used for training. While this is not strictly necessary, as the model using IFT data will already be capable of training an LLM-as-a-Judge, we show that such training data can give improved performance (see Appendix A.3 for supporting results). In this data, the input prompt asks the model to evaluate the quality of a given response to a particular instruction.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "2.1 Initialization",
        "chunkIndex": 11,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-12",
      "content": "ing data can give improved performance (see Appendix A.3 for supporting results). In this data, the input prompt asks the model to evaluate the quality of a given response to a particular instruction. The provided evaluation result response consists of chain-of-thought reasoning (a justification), followed by a final score (in our experiments out of 5). The exact prompt format we chose is given in Figure 2, which instructs the LLM to evaluate the response using five additive criteria (relevance, coverage, usefulness, clarity and expertise), covering various aspects of quality. Subsequently this will be referred to as Evaluation Fine-Tuning (EFT) data.\n\nWe use both these seed sets together during training.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "2.1 Initialization",
        "chunkIndex": 12,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-13",
      "content": "Using the model we have trained, we can make it self-modify its own training set. Specifically, we generate additional training data for the next iteration of training.\n\nThis consists of the following steps:\n\n1. Generate a new prompt: We generate a new prompt x i using few-shot prompting, sampling prompts from the original seed IFT data, following the approach of Wang et al. [2023] and Honovich et al. [2023]. 1\n2. Generate candidate responses: We then generate N diverse candidate responses { y 1 i , . . . , y N i } for the given prompt x i from our model using sampling.\n3. Evaluate candidate responses: Finally, we use the LLM-as-a-Judge ability of our same model to evaluate its own candidate responses with scores r n i ∈ [0 , 5] (exact prompt given in Figure 2).",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "2.2 Self-Instruction Creation",
        "chunkIndex": 13,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-14",
      "content": "As previously described, training is initially performed with the seed IFT and EFT data (Section 2.1). This is then augmented with additional data via AI (Self-)Feedback.\n\nAI Feedback Training After performing the self-instruction creation procedure, we can augment the seed data with additional examples for training, which we refer to as AI Feedback Training (AIFT) data.\n\nTo do this, we construct preference pairs , which are training data of the form (instruction prompt x i , winning response y w i , losing response y l i ). To form the winning and losing pair we take the highest and lowest scoring responses from the N evaluated candidate responses (see\n\n1 In our main experiments, responses and rewards, items (2) and (3), are generated by the model we have trained, but generating prompts is actually done by a model fixed in advance. However, we show that prompts can also be generated by the newly trained model in each iteration in Appendix A.5.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "2.3 Instruction Following Training",
        "chunkIndex": 14,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-15",
      "content": "we have trained, but generating prompts is actually done by a model fixed in advance. However, we show that prompts can also be generated by the newly trained model in each iteration in Appendix A.5.\n\nReview the user's question and the corresponding response using the additive 5-point scoring system described below. Points are accumulated based on the satisfaction of each criterion:\n\n-Add 1 point if the response is relevant and provides some information related to the user's inquiry, even if it is incomplete or contains some irrelevant content.\n\n- Add another point if the response addresses a substantial portion of the user's question, but does not completely resolve the query or provide a direct answer.\n\n- Award a third point if the response answers the basic elements of the user's question in a useful way, regardless of whether it seems to have been written by an AI Assistant or if it has elements typically found in blogs or search results.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "2.3 Instruction Following Training",
        "chunkIndex": 15,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-16",
      "content": "wers the basic elements of the user's question in a useful way, regardless of whether it seems to have been written by an AI Assistant or if it has elements typically found in blogs or search results.\n\n- Grant a fourth point if the response is clearly written from an AI Assistant's perspective, addressing the user's question directly and comprehensively, and is well-organized and helpful, even if there is slight room for improvement in clarity, conciseness or focus.\n\n- Bestow a fifth point for a response that is impeccably tailored to the user's question by an AI Assistant, without extraneous information, reflecting expert knowledge, and demonstrating a high-quality, engaging, and insightful answer.\n\nUser: &lt;INSTRUCTION\\_HERE&gt;\n\n&lt;response&gt; &lt;RESPONSE\\_HERE&gt; &lt;/response&gt;\n\nAfter examining the user's instruction and the response:\n\n- Briefly justify your total score, up to 100 words.\n- Conclude with the score using the format: 'Score: &lt;total points&gt;'",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "2.3 Instruction Following Training",
        "chunkIndex": 16,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-17",
      "content": ";/response&gt;\n\nAfter examining the user's instruction and the response:\n\n- Briefly justify your total score, up to 100 words.\n- Conclude with the score using the format: 'Score: &lt;total points&gt;'\n\nRemember to assess from the AI Assistant perspective, utilizing web search knowledge as necessary. To evaluate the response in alignment with this additive scoring model, we'll systematically attribute points based on the outlined criteria.\n\nFigure 2: LLM-as-a-Judge prompt for our LLM to act as a reward model and provide self-rewards for its own model generations. The model is initially trained with seed training data of how to perform well at this task, and then improves at this task further through our self-rewarding training procedure.\n\nSection 2.2), following Xu et al. [2023], discarding the pair if their scores are the same. These pairs can be used for training with a preference tuning algorithm. We use DPO [Rafailov et al., 2023].",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "2.3 Instruction Following Training",
        "chunkIndex": 17,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-18",
      "content": "the pair if their scores are the same. These pairs can be used for training with a preference tuning algorithm. We use DPO [Rafailov et al., 2023].",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "2.3 Instruction Following Training",
        "chunkIndex": 18,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-19",
      "content": "Iterative Training Our overall procedure trains a series of models M 1 , . . . , M T where each successive model t uses augmented training data created by the t -1 th model. We thus define AIFT( M t ) to mean AI Feedback Training data created using model M t .\n\nModel Sequence We define the models, and the training data they use as follows:\n\nM 0 : Base pretrained LLM with no fine-tuning.\n\nM 1 : Initialized with M 0 , then fine-tuned on the IFT+EFT seed data using SFT.\n\nM 2 : Initialized with M 1 , then trained with AIFT( M 1 ) data using DPO.\n\nM 3 : Initialized with M 2 , then trained with AIFT( M 2 ) data using DPO.\n\nThis iterative training resembles the procedure used in Pairwise Cringe Optimization and specifically is termed Iterative DPO, introduced in Xu et al. [2023]; however, an external fixed reward model was used in that work.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "2.4 Overall Self-Alignment Algorithm",
        "chunkIndex": 19,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-20",
      "content": "Base Model In our experiments we use Llama 2 70B [Touvron et al., 2023] as our base pretrained model.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.1 Experimental Setup",
        "chunkIndex": 20,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-21",
      "content": "IFT Seed Data We use the human-authored examples provided in the Open Assistant dataset [Köpf et al., 2023] for instruction fine-tuning. Following Li et al. [2024] we use 3200 examples, by sampling only first conversational turns in the English language that are high-quality, based on their human annotated rank (choosing only the highest rank 0). In our experiments, we compare to a model fine-tuned from the base model using only this data via supervised fine-tuning, and refer to it as our SFT baseline .\n\nEFT Seed Data The Open Assistant data also provides multiple ranked human responses per prompt from which we can construct evaluation fine-tuning data. We split this into train and evaluation sets, and use it to create LLM-as-a-Judge data. This is done by placing it in the input format given in Figure 2, which consists of the scoring criteria description, and the given instruction and response to be evaluated.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.1.1 Seed Training Data",
        "chunkIndex": 21,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-22",
      "content": "reate LLM-as-a-Judge data. This is done by placing it in the input format given in Figure 2, which consists of the scoring criteria description, and the given instruction and response to be evaluated. 2 For training targets, chain-of-thought justifications and final scores out of 5 are not directly provided, so we use the SFT baseline to generate such output evaluations for each input, and accept them into the training set if the ranking of their scores agrees with the human rankings in the dataset. We resample the training set by discarding some of the data that receives the most common score so that the scores are not too skewed, as we observe many samples receive a score of 4. This results in 1,630 train and 541 evaluation examples (which do not overlap with the IFT data).",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.1.1 Seed Training Data",
        "chunkIndex": 22,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-23",
      "content": "We evaluate the performance of our self-rewarding models in two axes: their ability to follow instructions, and their ability as a reward model (ability to evaluate responses).\n\nInstruction Following We evaluate head-to-head performance between various models using GPT-4 [Achiam et al., 2023] as an evaluator over 256 test prompts (which we refer to as IFT test data) derived from various sources following Li et al. [2024] using the AlpacaEval evaluation prompt [Li et al., 2023]. We try the prompt in both orders comparing pairwise, and if the GPT-4 evaluations disagree we count the result as a tie. We also perform a similar evaluation with humans (authors). We additionally report results in the AlpacaEval 2.0 leaderboard format which is evaluated over 805 prompts, and compute the win rate against the baseline GPT-4 Turbo model based on GPT-4 judgments.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.1.2 Evaluation Metrics",
        "chunkIndex": 23,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-24",
      "content": ". We additionally report results in the AlpacaEval 2.0 leaderboard format which is evaluated over 805 prompts, and compute the win rate against the baseline GPT-4 Turbo model based on GPT-4 judgments. Further, we report results on MT-Bench [Zheng et al., 2023b] a set of challenging multi-turn questions in various categories from math and coding to roleplay and writing, which uses GPT-4 to grade the model responses out of 10. Finally we also test the models on a set of 9 NLP benchmarks: ARC-Easy [Clark et al., 2018], ARC-Challenge [Clark et al., 2018], HellaSwag [Zellers et al., 2019], SIQA [Sap et al., 2019], PIQA [Bisk et al., 2020], GSM8K [Cobbe et al., 2021], MMLU [Hendrycks et al., 2021], OBQA [Mihaylov et al., 2018] and NQ [Kwiatkowski et al., 2019].\n\nReward Modeling We evaluate the correlation with human rankings on the evaluation set we derived from the Open Assistant dataset, as described in Section 3.1.1. Each instruction has on average 2.85 responses with given rankings.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.1.2 Evaluation Metrics",
        "chunkIndex": 24,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-25",
      "content": "the correlation with human rankings on the evaluation set we derived from the Open Assistant dataset, as described in Section 3.1.1. Each instruction has on average 2.85 responses with given rankings. We can thus measure the pairwise accuracy , which is how many times the order of the ranking between any given pair agrees between the model's evaluation and the human ranking. We also measure the exact match count, which is how often the total ordering is exactly the same for an instruction. We also report the Spearman correlation and Kendall's τ . Finally, we report how often the responses that the model scores a perfect 5 out of 5 are rated as the highest ranked by humans.\n\n2 Note, the prompt, derived from Li et al. [2024], mentions 'utilizing web search', but our model is not actually capable of this action.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.1.2 Evaluation Metrics",
        "chunkIndex": 25,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-26",
      "content": "Instruction following training The training hyperparameters we use are as follows. For SFT we use learning rate 5 . 5 e -6 which decays (cosine) to 1 . 1 e -6 at the end of training, batch size 16 and dropout 0 . 1. We only calculate the loss on target tokens instead of the full sequence. For DPO we use learning rate 1 e -6 which decays to 1 e -7, batch size 16, dropout 0 . 1, and a β value of 0.1. We perform early stopping by saving a checkpoint every 200 steps and evaluating generations using Claude 2 [Anthropic, 2023] on 253 validation examples derived from various sources following Li et al. [2024]. This is evaluated pairwise against the previous step's generations using the AlpacaEval evaluation prompt format [Li et al., 2023].\n\nSelf-Instruction creation To generate new prompts we use a fixed model, Llama 2-Chat 70B with 8-shot prompting following Self-Instruct [Wang et al., 2023], where we sample six demonstrations from the IFT data and two from the model generated data, and use",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.1.3 Training Details",
        "chunkIndex": 26,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-27",
      "content": "a fixed model, Llama 2-Chat 70B with 8-shot prompting following Self-Instruct [Wang et al., 2023], where we sample six demonstrations from the IFT data and two from the model generated data, and use decoding parameters T = 0.6, p = 0.9. We use their prompt template for non-classification tasks and apply the same filtering techniques, including the ROUGE-L [Lin, 2004] similarity check, keyword filtering, and length filtering. Except for the prompt generation part, the other parts of the creation pipeline (generating the response, and evaluating it) use the Self-Rewarding model being trained. For candidate response generation we sample N = 4 candidate responses with temperature T = 0 . 7, p = 0 . 9. When evaluating candidate responses, as there is variance to these scores, in our experiments we also use sampled decoding (with the same parameters) and generate these evaluations multiple (3) times and take the average.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.1.3 Training Details",
        "chunkIndex": 27,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-28",
      "content": "date responses, as there is variance to these scores, in our experiments we also use sampled decoding (with the same parameters) and generate these evaluations multiple (3) times and take the average. We added 3,964 such preference pairs to form the AIFT( M 1 ) dataset used to train M 2 via DPO, and 6,942 pairs to form AIFT( M 2 ) used to train M 3 .",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.1.3 Training Details",
        "chunkIndex": 28,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-29",
      "content": "Head to head performance results are provided in Figure 3.\n\nEFT+IFT seed training performs similarly to IFT alone We find that adding the Evaluation Fine-Tuning (EFT) task to training does not impact instruction following performance compared to using Instruction Fine-Tuning (IFT) data alone with an almost equal head to head (30.5% wins vs. 30.9% wins). This is a positive result because it means the increased capability of a model to self-reward does not affect its other skills. We can thus use IFT+EFT training as Iteration 1 ( M 1 ) of our Self-Rewarding model, and then run further iterations.\n\nIteration 2 ( M 2 ) improves over Iteration 1 ( M 1 ) and SFT Baseline Iteration 2 of Self-Rewarding training ( M 2 ) provides superior instruction following to Iteration 1 ( M 1 ) with 55.5% wins for M 2 compared to only 11.7% for M 1 in a head to head evaluation. It provides similar gains over the SFT Baseline as well (49.2% wins vs. 14.5% wins).",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.1 Instruction Following Ability",
        "chunkIndex": 29,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-30",
      "content": "llowing to Iteration 1 ( M 1 ) with 55.5% wins for M 2 compared to only 11.7% for M 1 in a head to head evaluation. It provides similar gains over the SFT Baseline as well (49.2% wins vs. 14.5% wins). Clearly, there is a large jump in performance from M 1 to M 2 by using the preference data AIFT( M 1 ) provided by the reward model from Iteration 1.\n\nIteration 3 ( M 3 ) improves over Iteration 2 ( M 2 ) We see a further gain in Iteration 3 over Iteration 2, with 47.7% wins for M 3 compared to only 12.5% for M 2 in a head to head evaluation. Similarly, the win rate over the SFT Baseline for M 3 increases to 62.5% wins vs. 9.8%, i.e., winning more often than the M 2 model did. Overall, we see large gains from M 2 to M 3 through training using the preference data AIFT( M 2 ) provided by the reward model from Iteration 2.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.1 Instruction Following Ability",
        "chunkIndex": 30,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-31",
      "content": "9.8%, i.e., winning more often than the M 2 model did. Overall, we see large gains from M 2 to M 3 through training using the preference data AIFT( M 2 ) provided by the reward model from Iteration 2.\n\nSelf-Rewarding models perform well on AlpacaEval 2 leaderboard We evaluate our models on the AlpacaEval 2.0 leaderboard format, with results given in Table 1. We observe the same findings as in the head-to-head evaluations, that training iterations yield improved win rates, in this case over GPT4-Turbo, from 9.94% in Iteration 1, to 15.38% in Iteration 2, to 20.44% in Iteration 3. Our Iteration 3 model outperforms many existing models in this metric, including Claude 2, Gemini Pro, and GPT4 0613. We show some\n\nFigure 3: Instruction following ability improves with Self-Training: We evaluate our models using head-to-head win rates on diverse prompts using GPT-4. The SFT Baseline is on par with Self-Rewarding Iteration 1 ( M 1 ).",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.1 Instruction Following Ability",
        "chunkIndex": 31,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-32",
      "content": "n following ability improves with Self-Training: We evaluate our models using head-to-head win rates on diverse prompts using GPT-4. The SFT Baseline is on par with Self-Rewarding Iteration 1 ( M 1 ). However, Iteration 2 ( M 2 ) outperforms both Iteration 1 ( M 1 ) and the SFT Baseline. Iteration 3 ( M 3 ) gives further gains over Iteration 2 ( M 2 ), outperforming M 1 , M 2 and the SFT Baseline by a large margin.\n\n<!-- image -->\n\nselected models from the leaderboard in the table. We note that many of those competing models contain either proprietary alignment data (which is typically large, e.g., over 1M annotations in Touvron et al. [2023]) or use targets that are distilled from stronger models. In contrast, our Self-Rewarding model starts from a small set of seed data from Open Assistant, and then generates targets and rewards from the model itself for further iterations of training.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.1 Instruction Following Ability",
        "chunkIndex": 32,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-33",
      "content": "models. In contrast, our Self-Rewarding model starts from a small set of seed data from Open Assistant, and then generates targets and rewards from the model itself for further iterations of training.\n\nFine-grained analysis As described earlier, the overall performance of the model in AlpacaEval improves with each iteration of training. It would be interesting to break down the overall performance improvement to see exactly what type of tasks these improvements come from. Therefore, we cluster the instructions in AlpacaEval test set into different groups based on three perspectives: (1) instruction category (2) instruction complexity (3) expected response length. We achieve this by using GPT-4. The detailed statistical information of the breakdown and the prompting techniques we used for getting this breakdown can be found in Appendix A.6. Results for the instruction category are given in Figure 4, and the other two in Appendix Figure 11.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.1 Instruction Following Ability",
        "chunkIndex": 33,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-34",
      "content": "kdown and the prompting techniques we used for getting this breakdown can be found in Appendix A.6. Results for the instruction category are given in Figure 4, and the other two in Appendix Figure 11. From the results we can conclude that (i) Self-Rewarding models can substantially improve the win rate in most categories, but there are some tasks for which this approach does not improve, such as mathematics and logical reasoning, indicating that our current training approach mainly allows the models to better utilize their existing knowledge. (ii) Through Self-Rewarding model training, the model's win rate increases on almost all tasks of different complexity, and especially on slightly more difficult tasks (complexity of 5, 6, 7 out of 10). (iii) The models also show a steady increase in the win rate on tasks with instructions with different expected response lengths.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.1 Instruction Following Ability",
        "chunkIndex": 34,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-35",
      "content": "ly on slightly more difficult tasks (complexity of 5, 6, 7 out of 10). (iii) The models also show a steady increase in the win rate on tasks with instructions with different expected response lengths.\n\nTable 1: AlpacaEval 2.0 results (win rate over GPT-4 Turbo evaluated by GPT-4). Self-Rewarding iterations yield improving win rates. Iteration 3 ( M 3 ) outperforms many existing models that use proprietary training data or targets distilled from stronger models.\n\n|                                                 |          | Alignment Targets   | Alignment Targets   |\n|-------------------------------------------------|----------|---------------------|---------------------|\n| Model                                           | Win Rate | Distilled           | Proprietary         |\n| Self-Rewarding 70B                              |          |                     |                     |\n| Iteration 1 ( M 1 )                             | 9.94%    |                     |",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.1 Instruction Following Ability",
        "chunkIndex": 35,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-36",
      "content": "ding 70B                              |          |                     |                     |\n| Iteration 1 ( M 1 )                             | 9.94%    |                     |                     |\n| Iteration 2 ( M 2 )                             | 15.38%   |                     |                     |\n| Iteration 3 ( M 3 )                             | 20.44%   |                     |                     |\n| Selected models from the leaderboard GPT-4 0314 | 22.07%   |                     | ✓                   |\n| Mistral Medium                                  | 21.86%   |                     | ✓                   |\n| Claude 2                                        | 17.19%   |                     | ✓                   |\n| Gemini Pro                                      | 16.85%   |                     | ✓                   |\n| GPT-4 0613                                      | 15.76%   |                     | ✓                   |\n| GPT 3.5 Turbo 0613",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.1 Instruction Following Ability",
        "chunkIndex": 36,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-37",
      "content": "| ✓                   |\n| GPT-4 0613                                      | 15.76%   |                     | ✓                   |\n| GPT 3.5 Turbo 0613                              | 14.13%   |                     | ✓                   |\n| LLaMA2 Chat 70B                                 | 13.87%   |                     | ✓                   |\n| Vicuna 33B v1.3                                 | 12.71%   | ✓                   |                     |\n| Humpback LLaMa2 70B                             | 10.12%   |                     |                     |\n| Guanaco 65B                                     | 6.86%    |                     |                     |\n| Davinci001                                      | 2.76%    |                     | ✓                   |\n| Alpaca 7B                                       | 2.59%    | ✓                   |                     |",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.1 Instruction Following Ability",
        "chunkIndex": 37,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-38",
      "content": "| 2.76%    |                     | ✓                   |\n| Alpaca 7B                                       | 2.59%    | ✓                   |                     |\n\nFigure 4: AlpacaEval win rate breakdown for instruction categories (full names given in Appendix). Self-Rewarding models give gains across several topics, but tend to e.g. give less gains on mathematics and reasoning tasks.\n\n<!-- image -->\n\nData distribution analysis We perform a t-SNE [Van der Maaten and Hinton, 2008] visualization of the IFT, EFT and AIFT( M 1 ) data, shown in Appendix A.1. We find good overlap between the IFT and AIFT( M 1 ) examples, which is desired, while the EFT examples lie in a different part of the embedding space, which can help explain why they would not affect IFT performance.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.1 Instruction Following Ability",
        "chunkIndex": 38,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-39",
      "content": "lap between the IFT and AIFT( M 1 ) examples, which is desired, while the EFT examples lie in a different part of the embedding space, which can help explain why they would not affect IFT performance. We observe that generations from M 1 on AlpacaEval have an average length of 1092, for M 2 they are 1552, and for M 3 they are 2552, so the model is learning to generate longer responses, which we note may be a factor in relative performance.\n\nFigure 5: Human evaluation results. Iterations of Self-Rewarding ( M 1 , M 2 and M 3 ) provide progressively better head-to-head win rates compared to the SFT baseline, in agreement with the automatic evaluation results.\n\n<!-- image -->\n\nTable 2: MT-Bench Results (on a scale of 10). Self-Rewarding iterations yield improving scores across various categories. Math, code &amp; reasoning performance and iteration gains are smaller than for other categories, likely due to the makeup of the Open Assistant seed data we use.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.1 Instruction Following Ability",
        "chunkIndex": 39,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-40",
      "content": "ing scores across various categories. Math, code &amp; reasoning performance and iteration gains are smaller than for other categories, likely due to the makeup of the Open Assistant seed data we use.\n\n|              |   Overall Score |   Math, Code & Reasoning |   Humanities, Extraction, STEM, Roleplay & Writing |\n|--------------|-----------------|--------------------------|----------------------------------------------------|\n| SFT Baseline |            6.85 |                     3.93 |                                               8.6  |\n| M 1          |            6.78 |                     3.83 |                                               8.55 |\n| M 2          |            7.01 |                     4.05 |                                               8.79 |\n| M 3          |            7.25 |                     4.17 |                                               9.1  |",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.1 Instruction Following Ability",
        "chunkIndex": 40,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-41",
      "content": ".01 |                     4.05 |                                               8.79 |\n| M 3          |            7.25 |                     4.17 |                                               9.1  |\n\nTable 3: NLP Benchmarks. Self-Rewarding models mostly tend to maintain performance compared to the Llama 2 70B base model and the SFT Baseline, despite being fine-tuned on very different instruction-following prompts.\n\n|              |   ARC ( ↑ ) challenge |   HellaSwag ( ↑ ) |   GSM8K ( ↑ ) |   MMLU ( ↑ ) |   NQ ( ↑ ) |\n|--------------|-----------------------|-------------------|---------------|--------------|------------|\n| Llama 2      |                 57.4  |             85.3  |         56.8  |        68.9  |      25.3  |\n| SFT Baseline |                 55.97 |             85.17 |         50.72 |        69.76 |      34.35 |\n| M 1          |                 57.51 |             84.99 |         60.27 |        69.34 |      35.48 |\n| M 2          |                 54.51 |             8",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.1 Instruction Following Ability",
        "chunkIndex": 41,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-42",
      "content": "50.72 |        69.76 |      34.35 |\n| M 1          |                 57.51 |             84.99 |         60.27 |        69.34 |      35.48 |\n| M 2          |                 54.51 |             84.27 |         59.29 |        69.31 |      33.07 |\n| M 3          |                 53.13 |             83.29 |         57.7  |        69.37 |      31.86 |\n\nHuman evaluation To examine whether human judgments align with automatic evaluation results, we conduct human evaluations that compare SFT baseline generations with the generations from each iteration of Self-Rewarding training, i.e., models M 1 , M 2 , and M 3 . Specifically, we randomly select 50 instructions from the IFT test set. Each instruction corresponds to three pairs of generations (i.e., baseline vs. M 1 , baseline vs. M 2 , baseline vs. M 3 ).",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.1 Instruction Following Ability",
        "chunkIndex": 42,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-43",
      "content": "3 . Specifically, we randomly select 50 instructions from the IFT test set. Each instruction corresponds to three pairs of generations (i.e., baseline vs. M 1 , baseline vs. M 2 , baseline vs. M 3 ). For each pair of generations, we assign them to three different annotators (blind evaluation performed by the authors) to make a pairwise judgment, and take a majority vote to decide which generation is better. The human evaluation results are shown in Figure 5. We find that Self-Rewarding models from later iterations show a larger advantage over the SFT baseline model, which is consistent with GPT-4's judgments, and demonstrates the effectiveness of our iterative training procedure.\n\nMT-Bench performance further validates these results We report performance on MT-Bench in Table 2 for the SFT baseline and iterations of the Self-Rewarding model. We",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.1 Instruction Following Ability",
        "chunkIndex": 43,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-44",
      "content": "our iterative training procedure.\n\nMT-Bench performance further validates these results We report performance on MT-Bench in Table 2 for the SFT baseline and iterations of the Self-Rewarding model. We\n\nTable 4: Reward Modeling ability improves with Self-Training : We evaluate the LLMas-a-Judge via various metrics which measure alignment with held-out human preference data. Self-Rewarding Iteration 2 (Model M 2 ), which is trained using the self-reward model derived from its previous iteration M 1 outperforms Iteration 1 ( M 1 ), while M 1 itself outperforms a standard SFT baseline model trained on only Instruction Fine-Tuning (IFT) data. Iteration 3 (Model M 3 ) gives further improvements over Iteration 2.\n\n|                       |              | Self-Rewarding Models   | Self-Rewarding Models   | Self-Rewarding Models            |\n|-----------------------|--------------|-------------------------|-------------------------|----------------------------------|\n| Model                 | S",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.1 Instruction Following Ability",
        "chunkIndex": 44,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-45",
      "content": "odels   | Self-Rewarding Models            |\n|-----------------------|--------------|-------------------------|-------------------------|----------------------------------|\n| Model                 | SFT Baseline | Iter 1 ( M 1 )          | Iter 2 ( M 2 )          | Iter 3 ( M 3 )                   |\n| Training data         | IFT          | IFT+EFT                 | IFT+EFT +AIFT( M 1 )    | IFT+EFT+AIFT( M 1 ) +AIFT( M 2 ) |\n| Pairwise acc. ( ↑ )   | 65.1%        | 78.7%                   | 80.4%                   | 81.7%                            |\n| 5-best % ( ↑ )        | 39.6%        | 41.5%                   | 44.3%                   | 43.2%                            |\n| Exact Match % ( ↑     | 10.1%        | 13.1%                   | 14.3%                   | 14.3%                            |\n| Spearman corr. ( ↑ )  | 0.253        | 0.279                   | 0.331                   | 0.349                            |\n| Kendall τ corr.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.1 Instruction Following Ability",
        "chunkIndex": 45,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-46",
      "content": "| 14.3%                            |\n| Spearman corr. ( ↑ )  | 0.253        | 0.279                   | 0.331                   | 0.349                            |\n| Kendall τ corr. ( ↑ ) | 0.233        | 0.253                   | 0.315                   | 0.324                            |\n\nagain see improvements across the iterations of training from M 1 to M 3 , from 6.78 (out of 10) up to 7.25, with larger relative gains in the humanities, STEM, roleplay, writing and extraction categories, and smaller gains in the math, code and reasoning categories. We expect that the latter is due to the seed prompts we use from Open Assistant tending to underemphasize the reasoning-based tasks. We note also that these improvements are in spite of our method using and constructing prompts that only involve a single turn, given the MT-Bench benchmark itself is a multi-turn evaluation.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.1 Instruction Following Ability",
        "chunkIndex": 46,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-47",
      "content": "d tasks. We note also that these improvements are in spite of our method using and constructing prompts that only involve a single turn, given the MT-Bench benchmark itself is a multi-turn evaluation.\n\nSelf-rewarding models did not lose ability on NLP Benchmarks As shown in Table 3, the performance of most NLP benchmark tasks evaluated are roughly similar to the baselines, with further detailed results on more datasets given in Appendix Table 9 that follow the same pattern. We hypothesize that given that our training data (seed data and synthetically generated data) are based on the Open Assistant prompts which may not be especially relevant to skills needed in the Table 3 tasks, it is expected that the task performance stays roughly similar, or may even drop. For example, in InstructGPT training [Ouyang et al., 2022] they found that 'during RLHF fine-tuning, we observe performance regressions compared to GPT-3 on certain public NLP datasets' which they refer to as an 'alignment tax.'",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.1 Instruction Following Ability",
        "chunkIndex": 47,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-48",
      "content": "raining [Ouyang et al., 2022] they found that 'during RLHF fine-tuning, we observe performance regressions compared to GPT-3 on certain public NLP datasets' which they refer to as an 'alignment tax.' A clear future direction is to extend the self-rewarding paradigm to these types of tasks, by relying not only on seed prompts from Open Assistant, but also on seed prompts found in a larger variety of datasets.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.1 Instruction Following Ability",
        "chunkIndex": 48,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-49",
      "content": "Reward modeling evaluation results are provided in Table 4.\n\nEFT augmentation improves over SFT baseline Firstly, we find that adding Evaluation Fine-Tuning (EFT) data into training, which gives examples to the model of how to act as an LLM-as-a-Judge, naturally improves its performance compared to training with Instruction Fine-Tuning (IFT) data alone. IFT data covers a wide range of general instruction tasks, and so does endow the SFT Baseline with the ability to evaluate responses; however, EFT data gives more examples of this specific task. We find improvements across all five metrics measured when using IFT+EFT vs. IFT alone, e.g., the pairwise accuracy agreement with humans increases from 65.1% to 78.7%.\n\nReward Modeling ability improves with Self-Training We find that performing a round of self-reward training improves the ability of the model at providing self-rewards for the next iteration , in addition to its improved instruction following ability.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.2 Reward Modeling Ability",
        "chunkIndex": 49,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-50",
      "content": "We find that performing a round of self-reward training improves the ability of the model at providing self-rewards for the next iteration , in addition to its improved instruction following ability. Model M 2 (Iteration 2) is trained using the reward model from M 1 (Iteration 1), but provides improved performance on all five metrics compared to M 1 . For example, pairwise accuracy improves\n\nfrom 78.7% to 80.4%. Iteration 3 ( M 3 ) improves several of these metrics further compared to M 2 , for example pairwise accuracy increases from 80.4% to 81.7%. This performance gain is achieved despite there being no additional EFT data provided, and the examples created during the Self-Instruction creation loop do not tend to look like LLM-as-a-Judge training examples. We hypothesize that because the model is becoming better at general instruction following, it nevertheless also improves at the LLM-as-a-Judge task.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.2 Reward Modeling Ability",
        "chunkIndex": 50,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-51",
      "content": "tend to look like LLM-as-a-Judge training examples. We hypothesize that because the model is becoming better at general instruction following, it nevertheless also improves at the LLM-as-a-Judge task.\n\nImportance of the LLM-as-a-Judge Prompt In these experiments we used the LLMas-a-Judge prompt format shown in Figure 2. In preliminary experiments we also tried various other prompts to decide the most effective one to use. For example, we tried the prompt proposed in Li et al. [2024] which also proposes a 5-point scale, but describes the options as multiple choice in a range of quality buckets, see Appendix Figure 7. In contrast, our prompt describes the points as additive, covering various aspects of quality. We find a large difference between these two prompts when using the SFT Baseline, e.g. 65.1% pairwise accuracy for ours, and only 26.6% pairwise accuracy for theirs. See Appendix A.2 for further details.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.2 Reward Modeling Ability",
        "chunkIndex": 51,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-52",
      "content": "e.g. 65.1% pairwise accuracy for ours, and only 26.6% pairwise accuracy for theirs. See Appendix A.2 for further details.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "3.2.2 Reward Modeling Ability",
        "chunkIndex": 52,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-53",
      "content": "Automatically improving or self-correcting large language models is becoming a major focus of research. A recent survey from Pan et al. [2023] attempts to summarize the topic. However, this is a rapidly moving area, and there are already promising new works not covered there.\n\nReinforcement Learning from Human Feedback (RLHF) Preference learning approaches such as in Ziegler et al. [2019], Stiennon et al. [2020], Ouyang et al. [2022], Bai et al. [2022a] train a fixed reward model from human preference data, and then use the reward model to train via reinforcement learning (RL), e.g. via Proximal Policy Optimization (PPO) [Schulman et al., 2017]. Thus, the reward signal in a certain sense already comes from a model even in these works, but distilled from human data. Nevertheless, this is commonly referred to as RL from Human Feedback (RLHF).",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "4 Related Work",
        "chunkIndex": 53,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-54",
      "content": ". Thus, the reward signal in a certain sense already comes from a model even in these works, but distilled from human data. Nevertheless, this is commonly referred to as RL from Human Feedback (RLHF). Methods such as Direct Preference Optimization (DPO) [Rafailov et al., 2023] avoid training the reward model entirely, and instead directly train the LLM using human preferences. Several other such competing methods exist as well [Zhao et al., 2023, Zheng et al., 2023a, Yuan et al., 2023], including Pairwise Cringe Optimization (PCO) [Xu et al., 2023]. PCO uses an iterative training approach similar to the one in our work, except with a fixed reward model, and that work also showed that Iterative DPO improves over DPO using the same scheme. We note that other works have developed iterative preference training schemes as well, e.g. Adolphs et al. [2023], Gulcehre et al. [2023], Xiong et al. [2023].",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "4 Related Work",
        "chunkIndex": 54,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-55",
      "content": "improves over DPO using the same scheme. We note that other works have developed iterative preference training schemes as well, e.g. Adolphs et al. [2023], Gulcehre et al. [2023], Xiong et al. [2023].\n\nReinforcement Learning from AI Feedback (RLAIF) Constitutional AI [Bai et al., 2022b] uses an LLM to give feedback and refine responses, and uses this data to train a reward model. This fixed, separate reward model is then used to train the language model via RL, called 'RL from AI Feedback' (RLAIF). Lee et al. [2023] compare RLAIF and RLHF procedures and find the methods they compare perform roughly equally. They use an 'off-the-shelf' LLM to perform LLM-as-a-Judge prompting to build a training set to train a fixed reward model, which is then used for RL training. They also experiment with using the fixed but separate LLM-as-a-Judge model directly, which the authors report is computationally expensive due to using it within PPO training (rather than the offline step in the iterative app",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "4 Related Work",
        "chunkIndex": 55,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-56",
      "content": "using the fixed but separate LLM-as-a-Judge model directly, which the authors report is computationally expensive due to using it within PPO training (rather than the offline step in the iterative approach we use in our work, which is relatively computationally cheap). Finally, SPIN [Chen et al., 2024b] recently showed they can avoid reward models entirely in an Iterative DPO-like framework by using human labels as the winning response in a pair, and the last iteration's generations as the losing response in the pair. The authors note this has the limitation that once the model generations reach human performance, they are bottlenecked. Further, each input prompt is required to have a human annotated response, in contrast to our work.\n\nImproving LLMs via data augmentation (and curation) Several methods have improved LLMs by (self-)creating training data to augment fine-tuning. Self-Instruct [Wang",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "4 Related Work",
        "chunkIndex": 56,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-57",
      "content": "response, in contrast to our work.\n\nImproving LLMs via data augmentation (and curation) Several methods have improved LLMs by (self-)creating training data to augment fine-tuning. Self-Instruct [Wang\n\net al., 2023] is a method for self-instruction creation of prompts and responses, which can be used to improve a base LLM. We make use of a similar technique in our work, and then use our self-reward model to score them. Several approaches have also created training data by distilling from powerful LLMs, and shown a weaker LLM can then perform well. For example, Alpaca [Taori et al., 2023] fine-tuned a Llama 7B model with text-davinci-003 instructions created in the style of self-instruct. Alpagasus [Chen et al., 2024a] employed a strong LLM-as-a-Judge (ChatGPT) to curate the Alpaca dataset and filter to a smaller set, obtaining improved results.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "4 Related Work",
        "chunkIndex": 57,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-58",
      "content": "s created in the style of self-instruct. Alpagasus [Chen et al., 2024a] employed a strong LLM-as-a-Judge (ChatGPT) to curate the Alpaca dataset and filter to a smaller set, obtaining improved results. Instruction Backtranslation [Li et al., 2024] similarly augments and curates training data, but augmenting via backtranslating from web documents to predict prompts. The curation is done by the LLM(-as-a-Judge) itself, so can be seen as an instance of a self-rewarding model, but in a specialized setting. Reinforced Self-Training (ReST) [Gulcehre et al., 2023] uses a fixed, external reward to curate new high-quality examples to iteratively add to the training set, improving performance. In our experiments, we found that adding only positive examples in a related manner did not help, whereas preference pairs did help (see Appendix Section A.4 for details).",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "4 Related Work",
        "chunkIndex": 58,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-59",
      "content": "set, improving performance. In our experiments, we found that adding only positive examples in a related manner did not help, whereas preference pairs did help (see Appendix Section A.4 for details).\n\nLLM-as-a-Judge Using LLM-as-a-Judge prompting to evaluate language models has become a standard approach [Dubois et al., 2023, Li et al., 2023, Fernandes et al., 2023, Bai et al., 2023, Saha et al., 2023], and is being used to train reward models or curate data as well, as described above [Lee et al., 2023, Chen et al., 2024a, Li et al., 2024]. While some works such as Kim et al. [2023] create training data to train an LLM to perform well as a judge, to our knowledge it is not common to combine this training with general instruction following skills as in our work.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "4 Related Work",
        "chunkIndex": 59,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-60",
      "content": "We have introduced Self-Rewarding Language Models, models capable of self-alignment via judging and training on their own generations. The method learns in an iterative manner, where in each iteration the model creates its own preference-based instruction training data. This is done by assigning rewards to its own generations via LLM-as-a-Judge prompting, and using Iterative DPO to train on the preferences. We showed that this training both improves the instruction following capability of the model, as well as its reward-modeling ability across the iterations. While there are many avenues left unexplored, we believe this is exciting because this means the model is better able to assign rewards in future iterations for improving instruction following - a kind of virtuous circle. While this improvement likely saturates in realistic scenarios, it still allows for the possibility of continual improvement beyond the human preferences that are typically used to build reward models and instru",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "5 Conclusion",
        "chunkIndex": 60,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-61",
      "content": "improvement likely saturates in realistic scenarios, it still allows for the possibility of continual improvement beyond the human preferences that are typically used to build reward models and instruction following models today.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "5 Conclusion",
        "chunkIndex": 61,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-62",
      "content": "While we have obtained promising experimental results, we currently consider them preliminary because there are many avenues yet to explore, among them the topics of further evaluation, including safety evaluation, and understanding the limits of iterative training.\n\nWe showed that the iterations of training improve both instruction following and reward modeling ability, but only ran three iterations in a single setting. A clear line of further research is to understand the 'scaling laws' of this effect both for more iterations, and with different language models with more or less capabilities in different settings.\n\nWe observed an increase in length in model generations, and there is a known correlation between length and estimated quality, which is a topic that should be understood more deeply in general, and in our results in particular as well. It would also be good to understand if so-called 'reward-hacking' can happen within our framework, and in what circumstances.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "6 Limitations",
        "chunkIndex": 62,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-63",
      "content": "derstood more deeply in general, and in our results in particular as well. It would also be good to understand if so-called 'reward-hacking' can happen within our framework, and in what circumstances. As we are using both a language model as the training reward, and a language model for final evaluation (GPT-4) in some of our benchmarks, even if they are different models, this may require a deeper analysis than we have provided. While the human evaluation we conducted did provide validation of the automatic results, further study could bring more insights.\n\nAnother clear further avenue of study is to conduct safety evaluations - and to explore safety training within our framework. Reward models have been built exclusively for safety in existing systems [Touvron et al., 2023], and a promising avenue here would be to use the LLM-as-a-Judge procedure to evaluate for safety specifically in our self-rewarding training process.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "6 Limitations",
        "chunkIndex": 63,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-64",
      "content": "safety in existing systems [Touvron et al., 2023], and a promising avenue here would be to use the LLM-as-a-Judge procedure to evaluate for safety specifically in our self-rewarding training process. Given that we have shown that reward modeling ability improves over training iterations, this could mean that the safety of the model could potentially improve over time as well, with later iterations being able to catch and mitigate more challenging safety situations that earlier iterations cannot.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "6 Limitations",
        "chunkIndex": 64,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-65",
      "content": "- Josh Achiam, Steven Adler, Sandhini Agarwal, Lama Ahmad, Ilge Akkaya, Florencia Leoni Aleman, Diogo Almeida, Janko Altenschmidt, Sam Altman, Shyamal Anadkat, et al. GPT-4 technical report. arXiv preprint arXiv:2303.08774 , 2023.\n- Leonard Adolphs, Tianyu Gao, Jing Xu, Kurt Shuster, Sainbayar Sukhbaatar, and Jason Weston. The CRINGE loss: Learning what language not to model. In Anna Rogers, Jordan Boyd-Graber, and Naoaki Okazaki, editors, Proceedings of the 61st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers) , pages 8854-8874, Toronto, Canada, July 2023. Association for Computational Linguistics. doi: 10.18653/ v1/2023.acl-long.493. URL https://aclanthology.org/2023.acl-long.493 .\n- Anthropic. Claude 2. https://www.anthropic.com/index/claude-2 , 2023.\n- Yuntao Bai, Andy Jones, Kamal Ndousse, Amanda Askell, Anna Chen, Nova DasSarma, Dawn Drain, Stanislav Fort, Deep Ganguli, Tom Henighan, et al.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "References",
        "chunkIndex": 65,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-66",
      "content": "ude 2. https://www.anthropic.com/index/claude-2 , 2023.\n- Yuntao Bai, Andy Jones, Kamal Ndousse, Amanda Askell, Anna Chen, Nova DasSarma, Dawn Drain, Stanislav Fort, Deep Ganguli, Tom Henighan, et al. Training a helpful and harmless assistant with reinforcement learning from human feedback. arXiv preprint arXiv:2204.05862 , 2022a.\n- Yuntao Bai, Saurav Kadavath, Sandipan Kundu, Amanda Askell, Jackson Kernion, Andy Jones, Anna Chen, Anna Goldie, Azalia Mirhoseini, Cameron McKinnon, et al. Constitutional AI: Harmlessness from AI feedback. arXiv preprint arXiv:2212.08073 , 2022b.\n- Yushi Bai, Jiahao Ying, Yixin Cao, Xin Lv, Yuze He, Xiaozhi Wang, Jifan Yu, Kaisheng Zeng, Yijia Xiao, Haozhe Lyu, Jiayin Zhang, Juanzi Li, and Lei Hou. Benchmarking foundation models with language-model-as-an-examiner. In Thirty-seventh Conference on Neural Information Processing Systems Datasets and Benchmarks Track , 2023.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "References",
        "chunkIndex": 66,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-67",
      "content": ", Juanzi Li, and Lei Hou. Benchmarking foundation models with language-model-as-an-examiner. In Thirty-seventh Conference on Neural Information Processing Systems Datasets and Benchmarks Track , 2023. URL https://openreview.net/forum?id=IiRHQ7gvnq .\n- Yonatan Bisk, Rowan Zellers, Ronan Le Bras, Jianfeng Gao, and Yejin Choi. Piqa: Reasoning about physical commonsense in natural language. In Thirty-Fourth AAAI Conference on Artificial Intelligence , 2020.\n- Lichang Chen, Shiyang Li, Jun Yan, Hai Wang, Kalpa Gunaratna, Vikas Yadav, Zheng Tang, Vijay Srinivasan, Tianyi Zhou, Heng Huang, et al. AlpaGasus: Training a better alpaca with fewer data. In The Twelfth International Conference on Learning Representations , 2024a. URL https://openreview.net/forum?id=FdVXgSJhvz .\n- Zixiang Chen, Yihe Deng, Huizhuo Yuan, Kaixuan Ji, and Quanquan Gu. Self-play fine-tuning converts weak language models to strong language models.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "References",
        "chunkIndex": 67,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-68",
      "content": "a. URL https://openreview.net/forum?id=FdVXgSJhvz .\n- Zixiang Chen, Yihe Deng, Huizhuo Yuan, Kaixuan Ji, and Quanquan Gu. Self-play fine-tuning converts weak language models to strong language models. arXiv preprint arXiv:2401.01335 , 2024b.\n- Peter Clark, Isaac Cowhey, Oren Etzioni, Tushar Khot, Ashish Sabharwal, Carissa Schoenick, and Oyvind Tafjord. Think you have solved question answering? Try ARC, the AI2 reasoning challenge. arXiv preprint arXiv:1803.05457 , 2018.\n- Karl Cobbe, Vineet Kosaraju, Mohammad Bavarian, Mark Chen, Heewoo Jun, Lukasz Kaiser, Matthias Plappert, Jerry Tworek, Jacob Hilton, Reiichiro Nakano, Christopher Hesse, and John Schulman. Training verifiers to solve math word problems. arXiv preprint arXiv:2110.14168 , 2021.\n- Ronan Collobert and Jason Weston. A unified architecture for natural language processing: Deep neural networks with multitask learning.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "References",
        "chunkIndex": 68,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-69",
      "content": "ve math word problems. arXiv preprint arXiv:2110.14168 , 2021.\n- Ronan Collobert and Jason Weston. A unified architecture for natural language processing: Deep neural networks with multitask learning. In Proceedings of the 25th International Conference on Machine Learning , pages 160-167, 2008.\n- Yann Dubois, Xuechen Li, Rohan Taori, Tianyi Zhang, Ishaan Gulrajani, Jimmy Ba, Carlos Guestrin, Percy Liang, and Tatsunori B Hashimoto. Alpacafarm: A simulation framework for methods that learn from human feedback. arXiv preprint arXiv:2305.14387 , 2023.\n- Patrick Fernandes, Daniel Deutsch, Mara Finkelstein, Parker Riley, André Martins, Graham Neubig, Ankush Garg, Jonathan Clark, Markus Freitag, and Orhan Firat. The devil is in the errors: Leveraging large language models for fine-grained machine translation evaluation.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "References",
        "chunkIndex": 69,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-70",
      "content": "ndré Martins, Graham Neubig, Ankush Garg, Jonathan Clark, Markus Freitag, and Orhan Firat. The devil is in the errors: Leveraging large language models for fine-grained machine translation evaluation.\n\nIn Philipp Koehn, Barry Haddow, Tom Kocmi, and Christof Monz, editors, Proceedings of the Eighth Conference on Machine Translation , pages 1066-1083, Singapore, December 2023. Association for Computational Linguistics. doi: 10.18653/v1/2023.wmt-1.100. URL https://aclanthology.org/2023.wmt-1.100 .\n\n- Caglar Gulcehre, Tom Le Paine, Srivatsan Srinivasan, Ksenia Konyushkova, Lotte Weerts, Abhishek Sharma, Aditya Siddhant, Alex Ahern, Miaosen Wang, Chenjie Gu, et al. Reinforced self-training (rest) for language modeling. arXiv preprint arXiv:2308.08998 , 2023.\n- Dan Hendrycks, Collin Burns, Steven Basart, Andy Zou, Mantas Mazeika, Dawn Song, and Jacob Steinhardt. Measuring massive multitask language understanding.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "References",
        "chunkIndex": 70,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-71",
      "content": "ng. arXiv preprint arXiv:2308.08998 , 2023.\n- Dan Hendrycks, Collin Burns, Steven Basart, Andy Zou, Mantas Mazeika, Dawn Song, and Jacob Steinhardt. Measuring massive multitask language understanding. In 9th International Conference on Learning Representations, ICLR 2021, Virtual Event, Austria, May 3-7, 2021 . OpenReview.net, 2021. URL https://openreview.net/forum?id=d7KBjmI3GmQ .\n- Or Honovich, Thomas Scialom, Omer Levy, and Timo Schick. Unnatural instructions: Tuning language models with (almost) no human labor. In Anna Rogers, Jordan Boyd-Graber, and Naoaki Okazaki, editors, Proceedings of the 61st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers) , pages 14409-14428, Toronto, Canada, July 2023. Association for Computational Linguistics. doi: 10.18653/v1/2023.acl-long.806.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "References",
        "chunkIndex": 71,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-72",
      "content": "of the Association for Computational Linguistics (Volume 1: Long Papers) , pages 14409-14428, Toronto, Canada, July 2023. Association for Computational Linguistics. doi: 10.18653/v1/2023.acl-long.806. URL https://aclanthology.org/2023.acl-long.806 .\n- Seungone Kim, Jamin Shin, Yejin Cho, Joel Jang, Shayne Longpre, Hwaran Lee, Sangdoo Yun, Seongjin Shin, Sungdong Kim, James Thorne, et al. Prometheus: Inducing fine-grained evaluation capability in language models. arXiv preprint arXiv:2310.08491 , 2023.\n- Andreas Köpf, Yannic Kilcher, Dimitri von Rütte, Sotiris Anagnostidis, Zhi-Rui Tam, Keith Stevens, Abdullah Barhoum, Nguyen Minh Duc, Oliver Stanley, Richárd Nagyfi, et al. OpenAssistant conversations-democratizing large language model alignment. arXiv preprint arXiv:2304.07327 , 2023.\n- Tom Kwiatkowski, Jennimaria Palomaki, Olivia Redfield, Michael Collins, Ankur Parikh, Chris Alberti, Danielle Epstein, Illia Polosukhin, Matthew Kelcey, Jacob Devlin, Kenton Lee, Kristina N.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "References",
        "chunkIndex": 72,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-73",
      "content": ", 2023.\n- Tom Kwiatkowski, Jennimaria Palomaki, Olivia Redfield, Michael Collins, Ankur Parikh, Chris Alberti, Danielle Epstein, Illia Polosukhin, Matthew Kelcey, Jacob Devlin, Kenton Lee, Kristina N. Toutanova, Llion Jones, Ming-Wei Chang, Andrew Dai, Jakob Uszkoreit, Quoc Le, and Slav Petrov. Natural questions: a benchmark for question answering research. Transactions of the Association of Computational Linguistics , 2019.\n- Harrison Lee, Samrat Phatale, Hassan Mansoor, Kellie Lu, Thomas Mesnard, Colton Bishop, Victor Carbune, and Abhinav Rastogi. RLAIF: Scaling reinforcement learning from human feedback with ai feedback. arXiv preprint arXiv:2309.00267 , 2023.\n- Xian Li, Ping Yu, Chunting Zhou, Timo Schick, Luke Zettlemoyer, Omer Levy, Jason Weston, and Mike Lewis. Self-alignment with instruction backtranslation. In The Twelfth International Conference on Learning Representations , 2024. URL https://openreview.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "References",
        "chunkIndex": 73,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-74",
      "content": "ttlemoyer, Omer Levy, Jason Weston, and Mike Lewis. Self-alignment with instruction backtranslation. In The Twelfth International Conference on Learning Representations , 2024. URL https://openreview. net/forum?id=1oijHJBRsT .\n- Xuechen Li, Tianyi Zhang, Yann Dubois, Rohan Taori, Ishaan Gulrajani, Carlos Guestrin, Percy Liang, and Tatsunori B. Hashimoto. Alpacaeval: An automatic evaluator of instruction-following models. https://github.com/tatsu-lab/alpaca\\_eval , 2023.\n- Chin-Yew Lin. ROUGE: A package for automatic evaluation of summaries. In Text Summarization Branches Out , pages 74-81, Barcelona, Spain, July 2004. Association for Computational Linguistics. URL https://aclanthology.org/W04-1013 .\n- Todor Mihaylov, Peter Clark, Tushar Khot, and Ashish Sabharwal. Can a suit of armor conduct electricity? a new dataset for open book question answering.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "References",
        "chunkIndex": 74,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-75",
      "content": "tics. URL https://aclanthology.org/W04-1013 .\n- Todor Mihaylov, Peter Clark, Tushar Khot, and Ashish Sabharwal. Can a suit of armor conduct electricity? a new dataset for open book question answering. In EMNLP , 2018.\n- Long Ouyang, Jeffrey Wu, Xu Jiang, Diogo Almeida, Carroll Wainwright, Pamela Mishkin, Chong Zhang, Sandhini Agarwal, Katarina Slama, Alex Ray, et al. Training language models to follow instructions with human feedback. Advances in Neural Information Processing Systems , 35:27730-27744, 2022.\n\n- Liangming Pan, Michael Saxon, Wenda Xu, Deepak Nathani, Xinyi Wang, and William Yang Wang. Automatically correcting large language models: Surveying the landscape of diverse self-correction strategies. arXiv preprint arXiv:2308.03188 , 2023.\n- Alec Radford, Jeffrey Wu, Rewon Child, David Luan, Dario Amodei, Ilya Sutskever, et al. Language models are unsupervised multitask learners.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "References",
        "chunkIndex": 75,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-76",
      "content": "ction strategies. arXiv preprint arXiv:2308.03188 , 2023.\n- Alec Radford, Jeffrey Wu, Rewon Child, David Luan, Dario Amodei, Ilya Sutskever, et al. Language models are unsupervised multitask learners. OpenAI blog , 1(8):9, 2019.\n- Rafael Rafailov, Archit Sharma, Eric Mitchell, Christopher D Manning, Stefano Ermon, and Chelsea Finn. Direct preference optimization: Your language model is secretly a reward model. In Thirty-seventh Conference on Neural Information Processing Systems , 2023. URL https://openreview.net/forum?id=HPuSIXJaa9 .\n- Swarnadeep Saha, Omer Levy, Asli Celikyilmaz, Mohit Bansal, Jason Weston, and Xian Li. Branch-solve-merge improves large language model evaluation and generation. arXiv preprint arXiv:2310.15123 , 2023.\n- Maarten Sap, Hannah Rashkin, Derek Chen, Ronan Le Bras, and Yejin Choi. Socialiqa: Commonsense reasoning about social interactions. CoRR , abs/1904.09728, 2019.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "References",
        "chunkIndex": 76,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-77",
      "content": "Xiv preprint arXiv:2310.15123 , 2023.\n- Maarten Sap, Hannah Rashkin, Derek Chen, Ronan Le Bras, and Yejin Choi. Socialiqa: Commonsense reasoning about social interactions. CoRR , abs/1904.09728, 2019. URL http://arxiv.org/abs/1904.09728 .\n- John Schulman, Filip Wolski, Prafulla Dhariwal, Alec Radford, and Oleg Klimov. Proximal policy optimization algorithms. arXiv preprint arXiv:1707.06347 , 2017.\n- Nisan Stiennon, Long Ouyang, Jeffrey Wu, Daniel Ziegler, Ryan Lowe, Chelsea Voss, Alec Radford, Dario Amodei, and Paul F Christiano. Learning to summarize with human feedback. Advances in Neural Information Processing Systems , 33:3008-3021, 2020.\n- Rohan Taori, Ishaan Gulrajani, Tianyi Zhang, Yann Dubois, Xuechen Li, Carlos Guestrin, Percy Liang, and Tatsunori B. Hashimoto. Stanford alpaca: An instruction-following llama model.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "References",
        "chunkIndex": 77,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-78",
      "content": "008-3021, 2020.\n- Rohan Taori, Ishaan Gulrajani, Tianyi Zhang, Yann Dubois, Xuechen Li, Carlos Guestrin, Percy Liang, and Tatsunori B. Hashimoto. Stanford alpaca: An instruction-following llama model. https://github.com/tatsu-lab/stanford\\_alpaca , 2023.\n- Hugo Touvron, Louis Martin, Kevin Stone, Peter Albert, Amjad Almahairi, Yasmine Babaei, Nikolay Bashlykov, Soumya Batra, Prajjwal Bhargava, Shruti Bhosale, et al. Llama 2: Open foundation and fine-tuned chat models. arXiv preprint arXiv:2307.09288 , 2023.\n- Laurens Van der Maaten and Geoffrey Hinton. Visualizing data using t-SNE. Journal of machine learning research , 9(11), 2008.\n- Yizhong Wang, Yeganeh Kordi, Swaroop Mishra, Alisa Liu, Noah A. Smith, Daniel Khashabi, and Hannaneh Hajishirzi. Self-instruct: Aligning language models with selfgenerated instructions.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "References",
        "chunkIndex": 78,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-79",
      "content": "9(11), 2008.\n- Yizhong Wang, Yeganeh Kordi, Swaroop Mishra, Alisa Liu, Noah A. Smith, Daniel Khashabi, and Hannaneh Hajishirzi. Self-instruct: Aligning language models with selfgenerated instructions. In Anna Rogers, Jordan Boyd-Graber, and Naoaki Okazaki, editors, Proceedings of the 61st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers) , pages 13484-13508, Toronto, Canada, July 2023. Association for Computational Linguistics. doi: 10.18653/v1/2023.acl-long.754. URL https://aclanthology.org/2023.acl-long.754 .\n- Wei Xiong, Hanze Dong, Chenlu Ye, Han Zhong, Nan Jiang, and Tong Zhang. Gibbs sampling from human feedback: A provable kl-constrained framework for rlhf. arXiv preprint arXiv:2312.11456 , 2023.\n- Jing Xu, Andrew Lee, Sainbayar Sukhbaatar, and Jason Weston. Some things are more cringe than others: Preference optimization with the pairwise cringe loss.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "References",
        "chunkIndex": 79,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-80",
      "content": ". arXiv preprint arXiv:2312.11456 , 2023.\n- Jing Xu, Andrew Lee, Sainbayar Sukhbaatar, and Jason Weston. Some things are more cringe than others: Preference optimization with the pairwise cringe loss. arXiv preprint arXiv:2312.16682 , 2023.\n- Hongyi Yuan, Zheng Yuan, Chuanqi Tan, Wei Wang, Songfang Huang, and Fei Huang. RRHF: Rank responses to align language models with human feedback. In Thirty-seventh Conference on Neural Information Processing Systems , 2023. URL https://openreview. net/forum?id=EdIGMCHk4l .\n- Rowan Zellers, Ari Holtzman, Yonatan Bisk, Ali Farhadi, and Yejin Choi. Hellaswag: Can a machine really finish your sentence? In Anna Korhonen, David R. Traum, and Lluís Màrquez, editors, Proceedings of the 57th Conference of the Association for Computational Linguistics, ACL 2019, Florence, Italy, July 28- August 2, 2019, Volume 1: Long Papers , pages 4791-4800. Association for Computational Linguistics, 2019. doi: 10.18653/V1/ P19-1472.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "References",
        "chunkIndex": 80,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-81",
      "content": "for Computational Linguistics, ACL 2019, Florence, Italy, July 28- August 2, 2019, Volume 1: Long Papers , pages 4791-4800. Association for Computational Linguistics, 2019. doi: 10.18653/V1/ P19-1472. URL https://doi.org/10.18653/v1/p19-1472 .\n\n- Yao Zhao, Rishabh Joshi, Tianqi Liu, Misha Khalman, Mohammad Saleh, and Peter J Liu. SLiC-HF: Sequence likelihood calibration with human feedback. arXiv preprint arXiv:2305.10425 , 2023.\n- Chujie Zheng, Pei Ke, Zheng Zhang, and Minlie Huang. Click: Controllable text generation with sequence likelihood contrastive learning. In Anna Rogers, Jordan Boyd-Graber, and Naoaki Okazaki, editors, Findings of the Association for Computational Linguistics: ACL 2023 , pages 1022-1040, Toronto, Canada, July 2023a. Association for Computational Linguistics. doi: 10.18653/v1/2023.findings-acl.65.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "References",
        "chunkIndex": 81,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-82",
      "content": "s, Findings of the Association for Computational Linguistics: ACL 2023 , pages 1022-1040, Toronto, Canada, July 2023a. Association for Computational Linguistics. doi: 10.18653/v1/2023.findings-acl.65. URL https://aclanthology.org/ 2023.findings-acl.65 .\n- Lianmin Zheng, Wei-Lin Chiang, Ying Sheng, Siyuan Zhuang, Zhanghao Wu, Yonghao Zhuang, Zi Lin, Zhuohan Li, Dacheng Li, Eric Xing, Hao Zhang, Joseph E. Gonzalez, and Ion Stoica. Judging LLM-as-a-judge with MT-bench and chatbot arena. In Thirty-seventh Conference on Neural Information Processing Systems Datasets and Benchmarks Track , 2023b. URL https://openreview.net/forum?id=uccHPGDlao .\n- Daniel M Ziegler, Nisan Stiennon, Jeffrey Wu, Tom B Brown, Alec Radford, Dario Amodei, Paul Christiano, and Geoffrey Irving. Fine-tuning language models from human preferences. arXiv preprint arXiv:1909.08593 , 2019.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "References",
        "chunkIndex": 82,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-83",
      "content": "(a) Instruction distribution of IFT, EFT and AIFT data. (b) Response distribution of IFT, EFT, and AIFT data.\n\n<!-- image -->\n\nFigure 6: Distributions of both instructions and responses for IFT, EFT and AIFT data.\n\nWe have plotted the distribution of instructions for IFT, EFT and AIFT( M 1 ) data, and the distribution of responses for IFT, EFT and AIFT( M 1 ) data in Figure 6. It is clear that the IFT data and EFT data come from very different distributions while the IFT and AIFT( M 1 ) data come from similar distributions.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "A.1 Distributions of IFT, EFT and AIFT data",
        "chunkIndex": 83,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-84",
      "content": "The EFT prompt which we use in our main experiments is shown in Figure 2.\n\nOther EFT prompts we have tried At first, we took the EFT prompt from Li et al. [2024] as shown in Figure 7. However, we found that this prompt was not as effective as our additive score-counting prompt because the model needed to treat the task as a multiple-choice problem, and it was difficult for the model to break down this multiple-choice problem into sub-problems involving evaluating various aspects of the response. When using the model trained on 3,200 IFT data only, its performance on the EFT test set using our additive score-counting prompt and prompt from Li et al. [2024] is shown in Table 5.\n\nTable 5: We tried various LLM-as-Judge prompts using the model trained with 3,200 IFT data only and found that our additive score-counting prompt worked best which demonstrates significant improvements in EFT performance comparing to the prompt used by Li et al. [2024].",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "A.2 EFT Prompts",
        "chunkIndex": 84,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-85",
      "content": "with 3,200 IFT data only and found that our additive score-counting prompt worked best which demonstrates significant improvements in EFT performance comparing to the prompt used by Li et al. [2024].\n\n| EFT Prompt              | Multiple Choice prompt   | Ours   |\n|-------------------------|--------------------------|--------|\n| Pairwise accuracy ( ↑ ) | 26.6%                    | 65.1%  |\n| 5-best % ( ↑ )          | 23.5%                    | 39.6%  |\n| Exact Match % ( ↑ )     | 1.1%                     | 10.1%  |\n| Spearman corr. ( ↑ )    | -0.18                    | 0.25   |\n| Kendall τ corr. ( ↑ )   | -0.16                    | 0.23   |",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "A.2 EFT Prompts",
        "chunkIndex": 85,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-86",
      "content": "To demonstrate the importance of the EFT data, we also trained a series of models starting with the model trained only on the IFT data. The following is the model sequence.\n\nM 0 : Base pretrained LLM with no fine-tuning.\n\nBelow is a question from an user and a candidate response. Please grade the response on a 5-point scale using the following criteria:\n\n1: It means the answer is incomplete, vague, off-topic, controversial, or not exactly what the user asked for. For example, some content seems missing, numbered list does not start from the beginning, the opening sentence repeats user's question. Or the response is from another person's perspective with their personal experience (e.g. taken from blog posts), or looks like an answer from a forum. Or it contains promotional text, navigation text, or other irrelevant information.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "A.3 Self-rewarding Models Using IFT Data Only",
        "chunkIndex": 86,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-87",
      "content": "rson's perspective with their personal experience (e.g. taken from blog posts), or looks like an answer from a forum. Or it contains promotional text, navigation text, or other irrelevant information.\n\n2: It means the answer addresses most of the asks from the user. It does not directly address the user's question. For example, it only provides a high-level methodology instead of the exact solution to user's question.\n\n3: It means the answer is helpful but not written by an AI Assistant. It addresses all the basic asks from the user. It is complete and self contained with the drawback that the response is not written from an AI assistant's perspective, but from other people's perspective. The content looks like an excerpt from a blog post, web page, or web search results. For example, it contains personal experience or opinion, mentions comments section, or share on social media, etc.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "A.3 Self-rewarding Models Using IFT Data Only",
        "chunkIndex": 87,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-88",
      "content": "The content looks like an excerpt from a blog post, web page, or web search results. For example, it contains personal experience or opinion, mentions comments section, or share on social media, etc.\n\n4: It means the answer is written from an AI assistant's perspective with a clear focus of addressing the instruction. It provide a complete, clear, and comprehensive response to user's question or instruction without missing or irrelevant information. It is well organized, self-contained, and written in a helpful tone. It has minor room for improvement, e.g. more concise and focused.\n\n5: It means it is a perfect answer from an AI Assistant. It has a clear focus on being a helpful AI Assistant, where the response looks like intentionally written to address the user's question or instruction without any irrelevant sentences. The answer provides high quality content, demonstrating expert knowledge in the area, is very well written, logical, easy-to-follow, engaging and insightful.\n\nUser:",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "A.3 Self-rewarding Models Using IFT Data Only",
        "chunkIndex": 88,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-89",
      "content": "n without any irrelevant sentences. The answer provides high quality content, demonstrating expert knowledge in the area, is very well written, logical, easy-to-follow, engaging and insightful.\n\nUser:\n\n```\n<INSTRUCTION_HERE>\n```\n\n&lt; response &gt;&lt;RESPONSE\\_HERE&gt;&lt; /response &gt;\n\nPlease first briefly describe your reasoning (in less than 100 words), and then write 'Score: &lt; rating &gt; ' in the last line. Answer in the style of an AI Assistant, with knowledge from web search if needed. To derive the final score based on the criteria, let's think step-by-step.\n\nFigure 7: LLM-as-a-Judge prompt taken from Li et al. [2024].\n\nM ′ 1 : Initialized with M 0 , then fine-tuned on the IFT seed data only using SFT.\n\nM ′ 2 : Initialized with M ′ 1 , then trained with AIFT( M ′ 1 ) data using DPO.\n\nM ′ 3 : Initialized with M ′ 2 , then trained with AIFT( M ′ 2 ) data using DPO.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "A.3 Self-rewarding Models Using IFT Data Only",
        "chunkIndex": 89,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-90",
      "content": "on the IFT seed data only using SFT.\n\nM ′ 2 : Initialized with M ′ 1 , then trained with AIFT( M ′ 1 ) data using DPO.\n\nM ′ 3 : Initialized with M ′ 2 , then trained with AIFT( M ′ 2 ) data using DPO.\n\nSince we did not use EFT data to train the series of models, they were not always able to score the responses according to the format and even when they did, the scores given typically converged to 4. Therefore, even when starting from the same number of generated new prompts, we could only collect a very small number of valid training samples for DPO. In total, we collected 541 pairs to form the AIFT( M ′ 1 ) dataset used to train M ′ 2 via DPO, and 429 pairs to form AIFT( M ′ 2 ) used to train M ′ 3 . The win rates are shown in Figure 8. From the figure we can conclude that EFT data helps to get better performance in the same number of iterations and the gap in performance between the model trained with EFT data and the model trained without EFT data widens in the later iterations.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "A.3 Self-rewarding Models Using IFT Data Only",
        "chunkIndex": 90,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-91",
      "content": "lps to get better performance in the same number of iterations and the gap in performance between the model trained with EFT data and the model trained without EFT data widens in the later iterations.\n\n<!-- image -->\n\n2\n\nFigure 8: EFT data helps the self-rewarding loop: We evaluated the series of models trained using self-reward loops starting from the model trained using only IFT data. We performed head-to-head win rates comparisons on the IFT test set. While M ′ 2 can improve over the SFT baseline and M ′ 3 can improve even more over the SFT baseline, they lag far behind the corresponding models ( M 2 , M 3 ) that started from a base model trained using both IFT and EFT data, see Figure 3.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "A.3 Self-rewarding Models Using IFT Data Only",
        "chunkIndex": 91,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-92",
      "content": "Given the above list of possible instructions, define a maximum of 20 categories that would cover the types of intructions, for example recipes, reasoning tasks, general knowledge etc. Try to cover as many of the instructions as possible with the maximum 20 categories, while keeping the categories high-level, simple and easy to understand.\n\nFigure 9: Prompt used to obtain instruction categories on the AlpacaEval test set.\n\nInstruction:\n\n&lt;INSTRUCTION&gt;\n\nGiven the above, categorize it into one of the following 20 categories:\n\n&lt;LIST ALL CATEGORIES&gt;\n\nSecondly, score the instruction in terms of complexity: how complex you think it is to answer from 1-10 (where 10 is a complex question whereby first reasoning or breaking down the question into multiple subquestions for example might help improve the answer).",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "&lt;LIST ALL ALPACAEVAL INSTRUCTIONS&gt;",
        "chunkIndex": 92,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-93",
      "content": "complex you think it is to answer from 1-10 (where 10 is a complex question whereby first reasoning or breaking down the question into multiple subquestions for example might help improve the answer).\n\nThirdly, indicate how long you think the response to the instruction should be, either (a) 1 sentence, (b) 1-3 sentences, (c) 1 paragraph, (d) 2 paragraphs, or (e) 3 or more paragraphs.\n\nProvide your final response in the following format:\n\nCategory:\n\n&lt; one of the 20 categories &gt;\n\nComplexity:\n\n&lt; score out of 10 &gt;\n\nLength:\n\n&lt; length category &gt; . Do not provide the actual response.\n\nFigure 10: Prompt for categorizing instructions based on their topics, complexities and expected response lengths.\n\nTable 6: Breakdown of AlpacaEval test set instructions by instruction category.\n\n| Category                                            |   Number | Percentage   |\n|-----------------------------------------------------|----------|--------------|\n| Science / Technology / Engineerin",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "&lt;LIST ALL ALPACAEVAL INSTRUCTIONS&gt;",
        "chunkIndex": 93,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-94",
      "content": "| Category                                            |   Number | Percentage   |\n|-----------------------------------------------------|----------|--------------|\n| Science / Technology / Engineering                  |      134 | 16.65%       |\n| Professional / Business / Marketing                 |       77 | 9.57%        |\n| Social Interaction / Relationships / Human Behavior |       68 | 8.45%        |\n| Miscellaneous / Other                               |       61 | 7.58%        |\n| Mathematics / Logical Reasoning                     |       52 | 6.46%        |\n| Cooking / Recipes                                   |       48 | 5.96%        |\n| Software Development / Coding / Algorithms          |       44 | 5.47%        |\n| Travel / Geography / Exploration                    |       41 | 5.09%        |\n| Literature / Writing / Communication                |       39 | 4.84%        |\n| History / Social Studies                            |       38 | 4.72%        |\n| Entertainment",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "&lt;LIST ALL ALPACAEVAL INSTRUCTIONS&gt;",
        "chunkIndex": 94,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-95",
      "content": "41 | 5.09%        |\n| Literature / Writing / Communication                |       39 | 4.84%        |\n| History / Social Studies                            |       38 | 4.72%        |\n| Entertainment / Media Analysis                      |       34 | 4.22%        |\n| Language Learning / Linguistics                     |       32 | 3.98%        |\n| Music / Audio / Arts                                |       30 | 3.73%        |\n| DIY Projects / Hobbies                              |       24 | 2.98%        |\n| Technology / Gadgets / Consumer Products            |       20 | 2.48%        |\n| Gaming / Game Development                           |       18 | 2.24%        |\n| Exercise / Health / Wellness                        |       16 | 1.99%        |\n| Philosophy / Ethics / Ideology                      |       15 | 1.86%        |\n| Sports / Athletics / Physical Activity              |       12 | 1.49%        |\n| Strategy / Problem-Solving / Critical Thinking      |        2 | 0.24%",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "&lt;LIST ALL ALPACAEVAL INSTRUCTIONS&gt;",
        "chunkIndex": 95,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-96",
      "content": "|       15 | 1.86%        |\n| Sports / Athletics / Physical Activity              |       12 | 1.49%        |\n| Strategy / Problem-Solving / Critical Thinking      |        2 | 0.24%        |\n\nTable 7: Breakdown of AlpacaEval test set instructions by instruction complexity. The instructions increase in complexity from 1 to 9, where 10 is a complex question that requires first reasoning or breaking the problem into sub-problems before it can be solved.\n\nFigure 11: AlpacaEval win rate breakdown for instruction complexities (left) and expected response lengths (right). Self-Rewarding models give gains across most complexities and all response length ranges.\n\n|   Complexity |   Number | Percentage   |\n|--------------|----------|--------------|\n|            3 |      238 | 29.57%       |\n|            2 |      206 | 25.59%       |\n|            4 |      122 | 15.16%       |\n|            6 |       79 | 9.81%        |\n|            5 |       68 | 8.45%        |\n|            7 |",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "&lt;LIST ALL ALPACAEVAL INSTRUCTIONS&gt;",
        "chunkIndex": 96,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-97",
      "content": "|\n|            2 |      206 | 25.59%       |\n|            4 |      122 | 15.16%       |\n|            6 |       79 | 9.81%        |\n|            5 |       68 | 8.45%        |\n|            7 |       41 | 5.09%        |\n|            1 |       34 | 4.22%        |\n|            8 |       14 | 1.74%        |\n|            9 |        3 | 0.37%        |\n\n<!-- image -->\n\nTable 8: Breakdown of AlpacaEval test set instructions by expected response length.\n\n| Expected Length      |   Number | Percentage   |\n|----------------------|----------|--------------|\n| 1-3 sentences        |      361 | 44.84%       |\n| 1 paragraph          |      269 | 33.42%       |\n| 1 sentence           |      143 | 17.76%       |\n| 2 paragraphs         |       31 | 3.85%        |\n| 3 or more paragraphs |        1 | 0.13%        |",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "&lt;LIST ALL ALPACAEVAL INSTRUCTIONS&gt;",
        "chunkIndex": 97,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-98",
      "content": "We also tried an alternative self-training procedure of adding high-quality self-instruction creation examples to supervised fine-tuning (without preference optimization), rather than DPO. In this variant, we add additional examples of (instruction prompt, response) curated by the model to the seed set for supervised fine-tuning, following other approaches [Li et al., 2024, Adolphs et al., 2023, Gulcehre et al., 2023], rather than constructing preference data. In this setup we only add examples where the candidate response was evaluated to give a perfect score of r n i = 5. Unfortunately we could not find a configuration where this approach helped. For example, adding 11,254 such examples that scored 5 out of 5, and optimizing the mixing weight in training, still yielded a head to head with the SFT Baseline of 29% wins vs 30% wins, i.e., no improvement.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "A.4 Preference optimization outperforms augmenting with positive examples only",
        "chunkIndex": 98,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-99",
      "content": "In our experiments, for time efficiency, we have created a fixed pool of augmented prompts in advance using ChatLlama 70B. In a real interactive system, ideally, those prompts could come from real users so that we can ensure the models are trained to align with real user requirements. Here, we also examine whether our newly trained Self-Rewarding models in each iteration can generate new prompts through in-context learning, instead of using ChatLlama 70B. To check this, we constructed 30 prompts with in-context examples using the original seed IFT data as described in Section 2.2 and tested whether M 1 , M 2 and M 3 still possess in-context learning ability and can generate high quality instructions. According to manual inspection, all models can generate novel instructions given in-context examples in all 30 cases.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "A.5 Augmented Prompt Generation Using Newly Trained Models",
        "chunkIndex": 99,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-100",
      "content": "ll possess in-context learning ability and can generate high quality instructions. According to manual inspection, all models can generate novel instructions given in-context examples in all 30 cases. However, for M 2 and M 3, the model is likely to first generate a few instructions, then generate a separator, and then start responding to the instructions, so some postprocessing might be necessary.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "A.5 Augmented Prompt Generation Using Newly Trained Models",
        "chunkIndex": 100,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-101",
      "content": "We used the GPT-4 ( gpt-4-1106-preview ) model to categorize the instructions in the AlpacaEval test set into clusters from three perspectives: (1) instruction category, (2) instruction complexity, and (3) expected response length. To obtain instruction categories for the AlpaceEval test set, we used the prompt in Figure 9 and obtained 20 categories in total. Then, to cluster the instructions into different groups, we use the prompt in Figure 10 for each test example. The corresponding statistics are given in Table 6, Table 7, Table 8. The fine-grained results on instruction complexity and expected response length are given in Figure 11.\n\nTable 9: NLP Benchmarks . Self-Rewarding models mostly tend to maintain performance compared to the Llama 2 base model and the SFT Baseline, despite being fine-tuned on very different instruction-following prompts.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "A.6 AlpacaEval Test Sample Clustering",
        "chunkIndex": 101,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-102",
      "content": "enchmarks . Self-Rewarding models mostly tend to maintain performance compared to the Llama 2 base model and the SFT Baseline, despite being fine-tuned on very different instruction-following prompts.\n\n|              | Commonsense Reasoning   | Commonsense Reasoning   | Commonsense Reasoning   | Commonsense Reasoning   | Commonsense Reasoning   | Math       | World Knowledge      | World Knowledge   | World Knowledge   |\n|--------------|-------------------------|-------------------------|-------------------------|-------------------------|-------------------------|------------|----------------------|-------------------|-------------------|\n|              | ARC easy                | ARC challenge           | HellaSwag               | SIQA                    | PIQA                    | GSM8K (em) | MMLU (macro_avg/acc) | OBQA (acc_comp)   | NQ (em)           |\n| Llama 2      | 80.20                   | 57.40                   | 85.30                   | 50.70                   | 82.80",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "A.6 AlpacaEval Test Sample Clustering",
        "chunkIndex": 102,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-103",
      "content": "(em) | MMLU (macro_avg/acc) | OBQA (acc_comp)   | NQ (em)           |\n| Llama 2      | 80.20                   | 57.40                   | 85.30                   | 50.70                   | 82.80                   | 56.80      | 68.90                | 60.20             | 25.30             |\n| SFT Baseline | 76.49                   | 55.97                   | 85.17                   | 51.48                   | 82.59                   | 50.72      | 69.76                | 57.80             | 34.35             |\n| M 1          | 78.14                   | 57.51                   | 84.99                   | 53.02                   | 82.92                   | 60.27      | 69.34                | 57.60             | 35.48             |\n| M 2          | 74.84                   | 54.51                   | 84.27                   | 51.23                   | 81.94                   | 59.29      | 69.31                | 57.60             | 33.07             |\n| M 3          | 72.35",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "A.6 AlpacaEval Test Sample Clustering",
        "chunkIndex": 103,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-104",
      "content": "| 84.27                   | 51.23                   | 81.94                   | 59.29      | 69.31                | 57.60             | 33.07             |\n| M 3          | 72.35                   | 53.13                   | 83.29                   | 49.28                   | 80.79                   | 57.70      | 69.37                | 58.40             | 31.86             |\n\nTable 10: MT-Bench Fine-grained Results . We list our models' performance on each problem category. Self-reward is especially effective in improving the model's ability in writing, role-playing, extraction, and STEM tasks.\n\n|     |   Writing |   Roleplay |   Reasoning |   Math |   Coding |   Extraction |   STEM |   Humanities |   Overall |\n|-----|-----------|------------|-------------|--------|----------|--------------|--------|--------------|-----------|\n| SFT |      8.83 |       8.15 |        5.3  |   3    |     3.5  |         6.9  |   9.18 |         9.95 |      6.85 |\n| M1  |      9.1  |       7.65 |",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "A.6 AlpacaEval Test Sample Clustering",
        "chunkIndex": 104,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-105",
      "content": "---------|--------|--------------|-----------|\n| SFT |      8.83 |       8.15 |        5.3  |   3    |     3.5  |         6.9  |   9.18 |         9.95 |      6.85 |\n| M1  |      9.1  |       7.65 |        4.35 |   3.05 |     4.1  |         7.2  |   8.93 |         9.85 |      6.78 |\n| M2  |      9.1  |       8    |        4.6  |   3.3  |     4.25 |         7.65 |   9.4  |         9.8  |      7.01 |\n| M3  |      9.58 |       8.73 |        4.8  |   3.5  |     4.2  |         7.8  |   9.45 |         9.95 |      7.25 |",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "A.6 AlpacaEval Test Sample Clustering",
        "chunkIndex": 105,
        "totalChunks": 107
      }
    },
    {
      "id": "2401.10020v3-chunk-106",
      "content": "We provide the detailed model performance on a number of NLP benchmarks in Table 9 and on MT-Bench in Table 10. In particular, some NLP benchmarks including ARC-Challenge, HellaSwag, SIQA, PIQA, and OBQA are all text completion tasks. In these tasks, given the multiple choice options, we choose the option corresponding to the highest log probability scored by the models as the final answer. As such, the objective of these particular tasks is quite different from what our algorithm tries to optimize, so the results on these tasks may not reflect the true capability of our models.",
      "metadata": {
        "source": "arxiv:2401.10020v3",
        "title": "Self-Rewarding Language Models",
        "authors": [
          "Weizhe Yuan",
          "Richard Yuanzhe Pang",
          "Kyunghyun Cho",
          "Xian Li",
          "Sainbayar Sukhbaatar",
          "Jing Xu",
          "Jason Weston"
        ],
        "section": "A.7 NLP Benchmark Results and MT-Bench Results",
        "chunkIndex": 106,
        "totalChunks": 107
      }
    }
  ],
  "fullText": "## Self-Rewarding Language Models\n\nWeizhe Yuan 1 , 2 Richard Yuanzhe Pang 1 , 2 Kyunghyun Cho 2 Xian Li 1 Sainbayar Sukhbaatar 1 Jing Xu 1 Jason Weston 1 , 2\n\n1 Meta\n\n2 NYU\n\n## Abstract\n\nWe posit that to achieve superhuman agents, future models require superhuman feedback in order to provide an adequate training signal. Current approaches commonly train reward models from human preferences, which may then be bottlenecked by human performance level, and secondly these separate frozen reward models cannot then learn to improve during LLM training. In this work, we study Self-Rewarding Language Models , where the language model itself is used via LLM-as-a-Judge prompting to provide its own rewards during training. We show that during Iterative DPO training that not only does instruction following ability improve, but also the ability to provide high-quality rewards to itself. Fine-tuning Llama 2 70B on three iterations of our approach yields a model that outperforms many existing systems on the AlpacaEval 2.0 leaderboard, including Claude 2, Gemini Pro, and GPT-4 0613. While there is much left still to explore, this work opens the door to the possibility of models that can continually improve in both axes.\n\n## 1 Introduction\n\nAligning Large Language Models (LLMs) using human preference data can vastly improve the instruction following performance of pretrained models [Ouyang et al., 2022, Bai et al., 2022a]. The standard approach of Reinforcement Learning from Human Feedback (RLHF) learns a reward model from these human preferences. The reward model is then frozen and used to train the LLM using RL, e.g., via PPO [Schulman et al., 2017]. A recent alternative is to avoid training the reward model at all, and directly use human preferences to train the LLM, as in Direct Preference Optimization [DPO; Rafailov et al., 2023]. In both cases, the approach is bottlenecked by the size and quality of the human preference data, and in the case of RLHF the quality of the frozen reward model trained from them as well.\n\nIn this work, we instead propose to train a self-improving reward model that, rather than being frozen, is continually updating during LLM alignment, in order to avoid this bottleneck. The key to such an approach is to develop an agent that possesses all the abilities desired during training, rather than separating them out into distinct models such as a reward model and a language model. In the same way that pretraining and multitasking training of instruction following tasks allow task transfer by training on many tasks at once [Collobert and Weston, 2008, Radford et al., 2019, Ouyang et al., 2022], incorporating the reward model into that same system allows task transfer between the reward modeling task and the instruction following tasks.\n\nWe thus introduce Self-Rewarding Language Models , that both (i) act as instruction following models generating responses for given prompts; and (ii) can generate and evaluate new instruction following examples to add to their own training set. We train these models using an Iterative DPO framework similar to that recently introduced in Xu et al. [2023].\n\nFigure 1: Self-Rewarding Language Models. Our self-alignment method consists of two steps: (i) Self-Instruction creation : newly created prompts are used to generate candidate responses from model M t , which also predicts its own rewards via LLM-as-a-Judge prompting. (ii) Instruction following training : preference pairs are selected from the generated data, which are used for training via DPO, resulting in model M t +1 . This whole procedure can then be iterated resulting in both improved instruction following and reward modeling ability.\n\n<!-- image -->\n\nStarting from a seed model, in each iteration there is a process of Self-Instruction creation whereby candidate responses are generated by the model for newly created prompts, and are then assigned rewards by that same model. The latter is implemented via LLM-as-a-Judge prompting, which can also be seen as an instruction following task. A preference dataset is built from the generated data, and the next iteration of the model is trained via DPO, see Figure 1.\n\nIn our experiments, we start with a Llama 2 70B [Touvron et al., 2023] seed model fine-tuned on Open Assistant [Köpf et al., 2023], and then perform the above training scheme. We find that not only does the instruction following performance improve from Self-Rewarding LLM alignment compared to the baseline seed model, but importantly the reward modeling ability, which is no longer fixed, improves as well. This means that the model during iterative training is able, at a given iteration, to provide a higher quality preference dataset to itself than in the previous iteration. While this effect likely saturates in real-world settings, it provides the intriguing possibility of obtaining reward models (and hence LLMs) that are superior to ones that could have been trained from the original human-authored seed data alone.\n\n## 2 Self-Rewarding Language Models\n\nOur approach first assumes access to a base pretrained language model, and a small amount of human-annotated seed data. We then build a model that aims to possess two skills simultaneously:\n\n1. Instruction following : given a prompt that describes a user request, the ability to generate a high quality, helpful (and harmless) response.\n2. Self-Instruction creation : the ability to generate and evaluate new instructionfollowing examples to add to its own training set.\n\nThese skills are used so that the model can perform self-alignment, i.e., they are the components used to iteratively train itself using AI Feedback (AIF).\n\nSelf-instruction creation consists of generating candidate responses and then the model itself judging their quality, i.e., it acts as its own reward model, replacing the need for an external one. This is implemented via the LLM-as-a-Judge mechanism [Zheng et al., 2023b], i.e., by formulating the evaluation of responses as an instruction following task. This self-created AIF preference data is used as a training set.\n\nOur overall self-alignment procedure is an iterative one, which proceeds by building a series of such models, with the aim that each improves over the last. Importantly, because the model can both improve its generation ability, and act as its own reward model through the same generation mechanism, this means the reward model itself can improve through these iterations, deviating from standard practices where the reward model is fixed [Ouyang et al.,\n\n2022]. We believe this can increase the ceiling of the potential for self-improvement of these learning models going forward, removing a constraining bottleneck.\n\nWe describe these steps in more detail below. An overview of the approach is illustrated in Figure 1.\n\n## 2.1 Initialization\n\nSeed instruction following data We are given a seed set of human-authored (instruction prompt, response) general instruction following examples that we use for training in a supervised fine-tuning (SFT) manner, starting from a pretrained base language model. Subsequently this will be referred to as Instruction Fine-Tuning (IFT) data.\n\nSeed LLM-as-a-Judge instruction following data We also assume we are provided a seed set of (evaluation instruction prompt, evaluation result response) examples which can also be used for training. While this is not strictly necessary, as the model using IFT data will already be capable of training an LLM-as-a-Judge, we show that such training data can give improved performance (see Appendix A.3 for supporting results). In this data, the input prompt asks the model to evaluate the quality of a given response to a particular instruction. The provided evaluation result response consists of chain-of-thought reasoning (a justification), followed by a final score (in our experiments out of 5). The exact prompt format we chose is given in Figure 2, which instructs the LLM to evaluate the response using five additive criteria (relevance, coverage, usefulness, clarity and expertise), covering various aspects of quality. Subsequently this will be referred to as Evaluation Fine-Tuning (EFT) data.\n\nWe use both these seed sets together during training.\n\n## 2.2 Self-Instruction Creation\n\nUsing the model we have trained, we can make it self-modify its own training set. Specifically, we generate additional training data for the next iteration of training.\n\nThis consists of the following steps:\n\n1. Generate a new prompt: We generate a new prompt x i using few-shot prompting, sampling prompts from the original seed IFT data, following the approach of Wang et al. [2023] and Honovich et al. [2023]. 1\n2. Generate candidate responses: We then generate N diverse candidate responses { y 1 i , . . . , y N i } for the given prompt x i from our model using sampling.\n3. Evaluate candidate responses: Finally, we use the LLM-as-a-Judge ability of our same model to evaluate its own candidate responses with scores r n i ∈ [0 , 5] (exact prompt given in Figure 2).\n\n## 2.3 Instruction Following Training\n\nAs previously described, training is initially performed with the seed IFT and EFT data (Section 2.1). This is then augmented with additional data via AI (Self-)Feedback.\n\nAI Feedback Training After performing the self-instruction creation procedure, we can augment the seed data with additional examples for training, which we refer to as AI Feedback Training (AIFT) data.\n\nTo do this, we construct preference pairs , which are training data of the form (instruction prompt x i , winning response y w i , losing response y l i ). To form the winning and losing pair we take the highest and lowest scoring responses from the N evaluated candidate responses (see\n\n1 In our main experiments, responses and rewards, items (2) and (3), are generated by the model we have trained, but generating prompts is actually done by a model fixed in advance. However, we show that prompts can also be generated by the newly trained model in each iteration in Appendix A.5.\n\nReview the user's question and the corresponding response using the additive 5-point scoring system described below. Points are accumulated based on the satisfaction of each criterion:\n\n-Add 1 point if the response is relevant and provides some information related to the user's inquiry, even if it is incomplete or contains some irrelevant content.\n\n- Add another point if the response addresses a substantial portion of the user's question, but does not completely resolve the query or provide a direct answer.\n\n- Award a third point if the response answers the basic elements of the user's question in a useful way, regardless of whether it seems to have been written by an AI Assistant or if it has elements typically found in blogs or search results.\n\n- Grant a fourth point if the response is clearly written from an AI Assistant's perspective, addressing the user's question directly and comprehensively, and is well-organized and helpful, even if there is slight room for improvement in clarity, conciseness or focus.\n\n- Bestow a fifth point for a response that is impeccably tailored to the user's question by an AI Assistant, without extraneous information, reflecting expert knowledge, and demonstrating a high-quality, engaging, and insightful answer.\n\nUser: &lt;INSTRUCTION\\_HERE&gt;\n\n&lt;response&gt; &lt;RESPONSE\\_HERE&gt; &lt;/response&gt;\n\nAfter examining the user's instruction and the response:\n\n- Briefly justify your total score, up to 100 words.\n- Conclude with the score using the format: 'Score: &lt;total points&gt;'\n\nRemember to assess from the AI Assistant perspective, utilizing web search knowledge as necessary. To evaluate the response in alignment with this additive scoring model, we'll systematically attribute points based on the outlined criteria.\n\nFigure 2: LLM-as-a-Judge prompt for our LLM to act as a reward model and provide self-rewards for its own model generations. The model is initially trained with seed training data of how to perform well at this task, and then improves at this task further through our self-rewarding training procedure.\n\nSection 2.2), following Xu et al. [2023], discarding the pair if their scores are the same. These pairs can be used for training with a preference tuning algorithm. We use DPO [Rafailov et al., 2023].\n\n## 2.4 Overall Self-Alignment Algorithm\n\nIterative Training Our overall procedure trains a series of models M 1 , . . . , M T where each successive model t uses augmented training data created by the t -1 th model. We thus define AIFT( M t ) to mean AI Feedback Training data created using model M t .\n\nModel Sequence We define the models, and the training data they use as follows:\n\nM 0 : Base pretrained LLM with no fine-tuning.\n\nM 1 : Initialized with M 0 , then fine-tuned on the IFT+EFT seed data using SFT.\n\nM 2 : Initialized with M 1 , then trained with AIFT( M 1 ) data using DPO.\n\nM 3 : Initialized with M 2 , then trained with AIFT( M 2 ) data using DPO.\n\nThis iterative training resembles the procedure used in Pairwise Cringe Optimization and specifically is termed Iterative DPO, introduced in Xu et al. [2023]; however, an external fixed reward model was used in that work.\n\n## 3 Experiments\n\n## 3.1 Experimental Setup\n\nBase Model In our experiments we use Llama 2 70B [Touvron et al., 2023] as our base pretrained model.\n\n## 3.1.1 Seed Training Data\n\nIFT Seed Data We use the human-authored examples provided in the Open Assistant dataset [Köpf et al., 2023] for instruction fine-tuning. Following Li et al. [2024] we use 3200 examples, by sampling only first conversational turns in the English language that are high-quality, based on their human annotated rank (choosing only the highest rank 0). In our experiments, we compare to a model fine-tuned from the base model using only this data via supervised fine-tuning, and refer to it as our SFT baseline .\n\nEFT Seed Data The Open Assistant data also provides multiple ranked human responses per prompt from which we can construct evaluation fine-tuning data. We split this into train and evaluation sets, and use it to create LLM-as-a-Judge data. This is done by placing it in the input format given in Figure 2, which consists of the scoring criteria description, and the given instruction and response to be evaluated. 2 For training targets, chain-of-thought justifications and final scores out of 5 are not directly provided, so we use the SFT baseline to generate such output evaluations for each input, and accept them into the training set if the ranking of their scores agrees with the human rankings in the dataset. We resample the training set by discarding some of the data that receives the most common score so that the scores are not too skewed, as we observe many samples receive a score of 4. This results in 1,630 train and 541 evaluation examples (which do not overlap with the IFT data).\n\n## 3.1.2 Evaluation Metrics\n\nWe evaluate the performance of our self-rewarding models in two axes: their ability to follow instructions, and their ability as a reward model (ability to evaluate responses).\n\nInstruction Following We evaluate head-to-head performance between various models using GPT-4 [Achiam et al., 2023] as an evaluator over 256 test prompts (which we refer to as IFT test data) derived from various sources following Li et al. [2024] using the AlpacaEval evaluation prompt [Li et al., 2023]. We try the prompt in both orders comparing pairwise, and if the GPT-4 evaluations disagree we count the result as a tie. We also perform a similar evaluation with humans (authors). We additionally report results in the AlpacaEval 2.0 leaderboard format which is evaluated over 805 prompts, and compute the win rate against the baseline GPT-4 Turbo model based on GPT-4 judgments. Further, we report results on MT-Bench [Zheng et al., 2023b] a set of challenging multi-turn questions in various categories from math and coding to roleplay and writing, which uses GPT-4 to grade the model responses out of 10. Finally we also test the models on a set of 9 NLP benchmarks: ARC-Easy [Clark et al., 2018], ARC-Challenge [Clark et al., 2018], HellaSwag [Zellers et al., 2019], SIQA [Sap et al., 2019], PIQA [Bisk et al., 2020], GSM8K [Cobbe et al., 2021], MMLU [Hendrycks et al., 2021], OBQA [Mihaylov et al., 2018] and NQ [Kwiatkowski et al., 2019].\n\nReward Modeling We evaluate the correlation with human rankings on the evaluation set we derived from the Open Assistant dataset, as described in Section 3.1.1. Each instruction has on average 2.85 responses with given rankings. We can thus measure the pairwise accuracy , which is how many times the order of the ranking between any given pair agrees between the model's evaluation and the human ranking. We also measure the exact match count, which is how often the total ordering is exactly the same for an instruction. We also report the Spearman correlation and Kendall's τ . Finally, we report how often the responses that the model scores a perfect 5 out of 5 are rated as the highest ranked by humans.\n\n2 Note, the prompt, derived from Li et al. [2024], mentions 'utilizing web search', but our model is not actually capable of this action.\n\n## 3.1.3 Training Details\n\nInstruction following training The training hyperparameters we use are as follows. For SFT we use learning rate 5 . 5 e -6 which decays (cosine) to 1 . 1 e -6 at the end of training, batch size 16 and dropout 0 . 1. We only calculate the loss on target tokens instead of the full sequence. For DPO we use learning rate 1 e -6 which decays to 1 e -7, batch size 16, dropout 0 . 1, and a β value of 0.1. We perform early stopping by saving a checkpoint every 200 steps and evaluating generations using Claude 2 [Anthropic, 2023] on 253 validation examples derived from various sources following Li et al. [2024]. This is evaluated pairwise against the previous step's generations using the AlpacaEval evaluation prompt format [Li et al., 2023].\n\nSelf-Instruction creation To generate new prompts we use a fixed model, Llama 2-Chat 70B with 8-shot prompting following Self-Instruct [Wang et al., 2023], where we sample six demonstrations from the IFT data and two from the model generated data, and use decoding parameters T = 0.6, p = 0.9. We use their prompt template for non-classification tasks and apply the same filtering techniques, including the ROUGE-L [Lin, 2004] similarity check, keyword filtering, and length filtering. Except for the prompt generation part, the other parts of the creation pipeline (generating the response, and evaluating it) use the Self-Rewarding model being trained. For candidate response generation we sample N = 4 candidate responses with temperature T = 0 . 7, p = 0 . 9. When evaluating candidate responses, as there is variance to these scores, in our experiments we also use sampled decoding (with the same parameters) and generate these evaluations multiple (3) times and take the average. We added 3,964 such preference pairs to form the AIFT( M 1 ) dataset used to train M 2 via DPO, and 6,942 pairs to form AIFT( M 2 ) used to train M 3 .\n\n## 3.2 Results\n\n## 3.2.1 Instruction Following Ability\n\nHead to head performance results are provided in Figure 3.\n\nEFT+IFT seed training performs similarly to IFT alone We find that adding the Evaluation Fine-Tuning (EFT) task to training does not impact instruction following performance compared to using Instruction Fine-Tuning (IFT) data alone with an almost equal head to head (30.5% wins vs. 30.9% wins). This is a positive result because it means the increased capability of a model to self-reward does not affect its other skills. We can thus use IFT+EFT training as Iteration 1 ( M 1 ) of our Self-Rewarding model, and then run further iterations.\n\nIteration 2 ( M 2 ) improves over Iteration 1 ( M 1 ) and SFT Baseline Iteration 2 of Self-Rewarding training ( M 2 ) provides superior instruction following to Iteration 1 ( M 1 ) with 55.5% wins for M 2 compared to only 11.7% for M 1 in a head to head evaluation. It provides similar gains over the SFT Baseline as well (49.2% wins vs. 14.5% wins). Clearly, there is a large jump in performance from M 1 to M 2 by using the preference data AIFT( M 1 ) provided by the reward model from Iteration 1.\n\nIteration 3 ( M 3 ) improves over Iteration 2 ( M 2 ) We see a further gain in Iteration 3 over Iteration 2, with 47.7% wins for M 3 compared to only 12.5% for M 2 in a head to head evaluation. Similarly, the win rate over the SFT Baseline for M 3 increases to 62.5% wins vs. 9.8%, i.e., winning more often than the M 2 model did. Overall, we see large gains from M 2 to M 3 through training using the preference data AIFT( M 2 ) provided by the reward model from Iteration 2.\n\nSelf-Rewarding models perform well on AlpacaEval 2 leaderboard We evaluate our models on the AlpacaEval 2.0 leaderboard format, with results given in Table 1. We observe the same findings as in the head-to-head evaluations, that training iterations yield improved win rates, in this case over GPT4-Turbo, from 9.94% in Iteration 1, to 15.38% in Iteration 2, to 20.44% in Iteration 3. Our Iteration 3 model outperforms many existing models in this metric, including Claude 2, Gemini Pro, and GPT4 0613. We show some\n\nFigure 3: Instruction following ability improves with Self-Training: We evaluate our models using head-to-head win rates on diverse prompts using GPT-4. The SFT Baseline is on par with Self-Rewarding Iteration 1 ( M 1 ). However, Iteration 2 ( M 2 ) outperforms both Iteration 1 ( M 1 ) and the SFT Baseline. Iteration 3 ( M 3 ) gives further gains over Iteration 2 ( M 2 ), outperforming M 1 , M 2 and the SFT Baseline by a large margin.\n\n<!-- image -->\n\nselected models from the leaderboard in the table. We note that many of those competing models contain either proprietary alignment data (which is typically large, e.g., over 1M annotations in Touvron et al. [2023]) or use targets that are distilled from stronger models. In contrast, our Self-Rewarding model starts from a small set of seed data from Open Assistant, and then generates targets and rewards from the model itself for further iterations of training.\n\nFine-grained analysis As described earlier, the overall performance of the model in AlpacaEval improves with each iteration of training. It would be interesting to break down the overall performance improvement to see exactly what type of tasks these improvements come from. Therefore, we cluster the instructions in AlpacaEval test set into different groups based on three perspectives: (1) instruction category (2) instruction complexity (3) expected response length. We achieve this by using GPT-4. The detailed statistical information of the breakdown and the prompting techniques we used for getting this breakdown can be found in Appendix A.6. Results for the instruction category are given in Figure 4, and the other two in Appendix Figure 11. From the results we can conclude that (i) Self-Rewarding models can substantially improve the win rate in most categories, but there are some tasks for which this approach does not improve, such as mathematics and logical reasoning, indicating that our current training approach mainly allows the models to better utilize their existing knowledge. (ii) Through Self-Rewarding model training, the model's win rate increases on almost all tasks of different complexity, and especially on slightly more difficult tasks (complexity of 5, 6, 7 out of 10). (iii) The models also show a steady increase in the win rate on tasks with instructions with different expected response lengths.\n\nTable 1: AlpacaEval 2.0 results (win rate over GPT-4 Turbo evaluated by GPT-4). Self-Rewarding iterations yield improving win rates. Iteration 3 ( M 3 ) outperforms many existing models that use proprietary training data or targets distilled from stronger models.\n\n|                                                 |          | Alignment Targets   | Alignment Targets   |\n|-------------------------------------------------|----------|---------------------|---------------------|\n| Model                                           | Win Rate | Distilled           | Proprietary         |\n| Self-Rewarding 70B                              |          |                     |                     |\n| Iteration 1 ( M 1 )                             | 9.94%    |                     |                     |\n| Iteration 2 ( M 2 )                             | 15.38%   |                     |                     |\n| Iteration 3 ( M 3 )                             | 20.44%   |                     |                     |\n| Selected models from the leaderboard GPT-4 0314 | 22.07%   |                     | ✓                   |\n| Mistral Medium                                  | 21.86%   |                     | ✓                   |\n| Claude 2                                        | 17.19%   |                     | ✓                   |\n| Gemini Pro                                      | 16.85%   |                     | ✓                   |\n| GPT-4 0613                                      | 15.76%   |                     | ✓                   |\n| GPT 3.5 Turbo 0613                              | 14.13%   |                     | ✓                   |\n| LLaMA2 Chat 70B                                 | 13.87%   |                     | ✓                   |\n| Vicuna 33B v1.3                                 | 12.71%   | ✓                   |                     |\n| Humpback LLaMa2 70B                             | 10.12%   |                     |                     |\n| Guanaco 65B                                     | 6.86%    |                     |                     |\n| Davinci001                                      | 2.76%    |                     | ✓                   |\n| Alpaca 7B                                       | 2.59%    | ✓                   |                     |\n\nFigure 4: AlpacaEval win rate breakdown for instruction categories (full names given in Appendix). Self-Rewarding models give gains across several topics, but tend to e.g. give less gains on mathematics and reasoning tasks.\n\n<!-- image -->\n\nData distribution analysis We perform a t-SNE [Van der Maaten and Hinton, 2008] visualization of the IFT, EFT and AIFT( M 1 ) data, shown in Appendix A.1. We find good overlap between the IFT and AIFT( M 1 ) examples, which is desired, while the EFT examples lie in a different part of the embedding space, which can help explain why they would not affect IFT performance. We observe that generations from M 1 on AlpacaEval have an average length of 1092, for M 2 they are 1552, and for M 3 they are 2552, so the model is learning to generate longer responses, which we note may be a factor in relative performance.\n\nFigure 5: Human evaluation results. Iterations of Self-Rewarding ( M 1 , M 2 and M 3 ) provide progressively better head-to-head win rates compared to the SFT baseline, in agreement with the automatic evaluation results.\n\n<!-- image -->\n\nTable 2: MT-Bench Results (on a scale of 10). Self-Rewarding iterations yield improving scores across various categories. Math, code &amp; reasoning performance and iteration gains are smaller than for other categories, likely due to the makeup of the Open Assistant seed data we use.\n\n|              |   Overall Score |   Math, Code & Reasoning |   Humanities, Extraction, STEM, Roleplay & Writing |\n|--------------|-----------------|--------------------------|----------------------------------------------------|\n| SFT Baseline |            6.85 |                     3.93 |                                               8.6  |\n| M 1          |            6.78 |                     3.83 |                                               8.55 |\n| M 2          |            7.01 |                     4.05 |                                               8.79 |\n| M 3          |            7.25 |                     4.17 |                                               9.1  |\n\nTable 3: NLP Benchmarks. Self-Rewarding models mostly tend to maintain performance compared to the Llama 2 70B base model and the SFT Baseline, despite being fine-tuned on very different instruction-following prompts.\n\n|              |   ARC ( ↑ ) challenge |   HellaSwag ( ↑ ) |   GSM8K ( ↑ ) |   MMLU ( ↑ ) |   NQ ( ↑ ) |\n|--------------|-----------------------|-------------------|---------------|--------------|------------|\n| Llama 2      |                 57.4  |             85.3  |         56.8  |        68.9  |      25.3  |\n| SFT Baseline |                 55.97 |             85.17 |         50.72 |        69.76 |      34.35 |\n| M 1          |                 57.51 |             84.99 |         60.27 |        69.34 |      35.48 |\n| M 2          |                 54.51 |             84.27 |         59.29 |        69.31 |      33.07 |\n| M 3          |                 53.13 |             83.29 |         57.7  |        69.37 |      31.86 |\n\nHuman evaluation To examine whether human judgments align with automatic evaluation results, we conduct human evaluations that compare SFT baseline generations with the generations from each iteration of Self-Rewarding training, i.e., models M 1 , M 2 , and M 3 . Specifically, we randomly select 50 instructions from the IFT test set. Each instruction corresponds to three pairs of generations (i.e., baseline vs. M 1 , baseline vs. M 2 , baseline vs. M 3 ). For each pair of generations, we assign them to three different annotators (blind evaluation performed by the authors) to make a pairwise judgment, and take a majority vote to decide which generation is better. The human evaluation results are shown in Figure 5. We find that Self-Rewarding models from later iterations show a larger advantage over the SFT baseline model, which is consistent with GPT-4's judgments, and demonstrates the effectiveness of our iterative training procedure.\n\nMT-Bench performance further validates these results We report performance on MT-Bench in Table 2 for the SFT baseline and iterations of the Self-Rewarding model. We\n\nTable 4: Reward Modeling ability improves with Self-Training : We evaluate the LLMas-a-Judge via various metrics which measure alignment with held-out human preference data. Self-Rewarding Iteration 2 (Model M 2 ), which is trained using the self-reward model derived from its previous iteration M 1 outperforms Iteration 1 ( M 1 ), while M 1 itself outperforms a standard SFT baseline model trained on only Instruction Fine-Tuning (IFT) data. Iteration 3 (Model M 3 ) gives further improvements over Iteration 2.\n\n|                       |              | Self-Rewarding Models   | Self-Rewarding Models   | Self-Rewarding Models            |\n|-----------------------|--------------|-------------------------|-------------------------|----------------------------------|\n| Model                 | SFT Baseline | Iter 1 ( M 1 )          | Iter 2 ( M 2 )          | Iter 3 ( M 3 )                   |\n| Training data         | IFT          | IFT+EFT                 | IFT+EFT +AIFT( M 1 )    | IFT+EFT+AIFT( M 1 ) +AIFT( M 2 ) |\n| Pairwise acc. ( ↑ )   | 65.1%        | 78.7%                   | 80.4%                   | 81.7%                            |\n| 5-best % ( ↑ )        | 39.6%        | 41.5%                   | 44.3%                   | 43.2%                            |\n| Exact Match % ( ↑     | 10.1%        | 13.1%                   | 14.3%                   | 14.3%                            |\n| Spearman corr. ( ↑ )  | 0.253        | 0.279                   | 0.331                   | 0.349                            |\n| Kendall τ corr. ( ↑ ) | 0.233        | 0.253                   | 0.315                   | 0.324                            |\n\nagain see improvements across the iterations of training from M 1 to M 3 , from 6.78 (out of 10) up to 7.25, with larger relative gains in the humanities, STEM, roleplay, writing and extraction categories, and smaller gains in the math, code and reasoning categories. We expect that the latter is due to the seed prompts we use from Open Assistant tending to underemphasize the reasoning-based tasks. We note also that these improvements are in spite of our method using and constructing prompts that only involve a single turn, given the MT-Bench benchmark itself is a multi-turn evaluation.\n\nSelf-rewarding models did not lose ability on NLP Benchmarks As shown in Table 3, the performance of most NLP benchmark tasks evaluated are roughly similar to the baselines, with further detailed results on more datasets given in Appendix Table 9 that follow the same pattern. We hypothesize that given that our training data (seed data and synthetically generated data) are based on the Open Assistant prompts which may not be especially relevant to skills needed in the Table 3 tasks, it is expected that the task performance stays roughly similar, or may even drop. For example, in InstructGPT training [Ouyang et al., 2022] they found that 'during RLHF fine-tuning, we observe performance regressions compared to GPT-3 on certain public NLP datasets' which they refer to as an 'alignment tax.' A clear future direction is to extend the self-rewarding paradigm to these types of tasks, by relying not only on seed prompts from Open Assistant, but also on seed prompts found in a larger variety of datasets.\n\n## 3.2.2 Reward Modeling Ability\n\nReward modeling evaluation results are provided in Table 4.\n\nEFT augmentation improves over SFT baseline Firstly, we find that adding Evaluation Fine-Tuning (EFT) data into training, which gives examples to the model of how to act as an LLM-as-a-Judge, naturally improves its performance compared to training with Instruction Fine-Tuning (IFT) data alone. IFT data covers a wide range of general instruction tasks, and so does endow the SFT Baseline with the ability to evaluate responses; however, EFT data gives more examples of this specific task. We find improvements across all five metrics measured when using IFT+EFT vs. IFT alone, e.g., the pairwise accuracy agreement with humans increases from 65.1% to 78.7%.\n\nReward Modeling ability improves with Self-Training We find that performing a round of self-reward training improves the ability of the model at providing self-rewards for the next iteration , in addition to its improved instruction following ability. Model M 2 (Iteration 2) is trained using the reward model from M 1 (Iteration 1), but provides improved performance on all five metrics compared to M 1 . For example, pairwise accuracy improves\n\nfrom 78.7% to 80.4%. Iteration 3 ( M 3 ) improves several of these metrics further compared to M 2 , for example pairwise accuracy increases from 80.4% to 81.7%. This performance gain is achieved despite there being no additional EFT data provided, and the examples created during the Self-Instruction creation loop do not tend to look like LLM-as-a-Judge training examples. We hypothesize that because the model is becoming better at general instruction following, it nevertheless also improves at the LLM-as-a-Judge task.\n\nImportance of the LLM-as-a-Judge Prompt In these experiments we used the LLMas-a-Judge prompt format shown in Figure 2. In preliminary experiments we also tried various other prompts to decide the most effective one to use. For example, we tried the prompt proposed in Li et al. [2024] which also proposes a 5-point scale, but describes the options as multiple choice in a range of quality buckets, see Appendix Figure 7. In contrast, our prompt describes the points as additive, covering various aspects of quality. We find a large difference between these two prompts when using the SFT Baseline, e.g. 65.1% pairwise accuracy for ours, and only 26.6% pairwise accuracy for theirs. See Appendix A.2 for further details.\n\n## 4 Related Work\n\nAutomatically improving or self-correcting large language models is becoming a major focus of research. A recent survey from Pan et al. [2023] attempts to summarize the topic. However, this is a rapidly moving area, and there are already promising new works not covered there.\n\nReinforcement Learning from Human Feedback (RLHF) Preference learning approaches such as in Ziegler et al. [2019], Stiennon et al. [2020], Ouyang et al. [2022], Bai et al. [2022a] train a fixed reward model from human preference data, and then use the reward model to train via reinforcement learning (RL), e.g. via Proximal Policy Optimization (PPO) [Schulman et al., 2017]. Thus, the reward signal in a certain sense already comes from a model even in these works, but distilled from human data. Nevertheless, this is commonly referred to as RL from Human Feedback (RLHF). Methods such as Direct Preference Optimization (DPO) [Rafailov et al., 2023] avoid training the reward model entirely, and instead directly train the LLM using human preferences. Several other such competing methods exist as well [Zhao et al., 2023, Zheng et al., 2023a, Yuan et al., 2023], including Pairwise Cringe Optimization (PCO) [Xu et al., 2023]. PCO uses an iterative training approach similar to the one in our work, except with a fixed reward model, and that work also showed that Iterative DPO improves over DPO using the same scheme. We note that other works have developed iterative preference training schemes as well, e.g. Adolphs et al. [2023], Gulcehre et al. [2023], Xiong et al. [2023].\n\nReinforcement Learning from AI Feedback (RLAIF) Constitutional AI [Bai et al., 2022b] uses an LLM to give feedback and refine responses, and uses this data to train a reward model. This fixed, separate reward model is then used to train the language model via RL, called 'RL from AI Feedback' (RLAIF). Lee et al. [2023] compare RLAIF and RLHF procedures and find the methods they compare perform roughly equally. They use an 'off-the-shelf' LLM to perform LLM-as-a-Judge prompting to build a training set to train a fixed reward model, which is then used for RL training. They also experiment with using the fixed but separate LLM-as-a-Judge model directly, which the authors report is computationally expensive due to using it within PPO training (rather than the offline step in the iterative approach we use in our work, which is relatively computationally cheap). Finally, SPIN [Chen et al., 2024b] recently showed they can avoid reward models entirely in an Iterative DPO-like framework by using human labels as the winning response in a pair, and the last iteration's generations as the losing response in the pair. The authors note this has the limitation that once the model generations reach human performance, they are bottlenecked. Further, each input prompt is required to have a human annotated response, in contrast to our work.\n\nImproving LLMs via data augmentation (and curation) Several methods have improved LLMs by (self-)creating training data to augment fine-tuning. Self-Instruct [Wang\n\net al., 2023] is a method for self-instruction creation of prompts and responses, which can be used to improve a base LLM. We make use of a similar technique in our work, and then use our self-reward model to score them. Several approaches have also created training data by distilling from powerful LLMs, and shown a weaker LLM can then perform well. For example, Alpaca [Taori et al., 2023] fine-tuned a Llama 7B model with text-davinci-003 instructions created in the style of self-instruct. Alpagasus [Chen et al., 2024a] employed a strong LLM-as-a-Judge (ChatGPT) to curate the Alpaca dataset and filter to a smaller set, obtaining improved results. Instruction Backtranslation [Li et al., 2024] similarly augments and curates training data, but augmenting via backtranslating from web documents to predict prompts. The curation is done by the LLM(-as-a-Judge) itself, so can be seen as an instance of a self-rewarding model, but in a specialized setting. Reinforced Self-Training (ReST) [Gulcehre et al., 2023] uses a fixed, external reward to curate new high-quality examples to iteratively add to the training set, improving performance. In our experiments, we found that adding only positive examples in a related manner did not help, whereas preference pairs did help (see Appendix Section A.4 for details).\n\nLLM-as-a-Judge Using LLM-as-a-Judge prompting to evaluate language models has become a standard approach [Dubois et al., 2023, Li et al., 2023, Fernandes et al., 2023, Bai et al., 2023, Saha et al., 2023], and is being used to train reward models or curate data as well, as described above [Lee et al., 2023, Chen et al., 2024a, Li et al., 2024]. While some works such as Kim et al. [2023] create training data to train an LLM to perform well as a judge, to our knowledge it is not common to combine this training with general instruction following skills as in our work.\n\n## 5 Conclusion\n\nWe have introduced Self-Rewarding Language Models, models capable of self-alignment via judging and training on their own generations. The method learns in an iterative manner, where in each iteration the model creates its own preference-based instruction training data. This is done by assigning rewards to its own generations via LLM-as-a-Judge prompting, and using Iterative DPO to train on the preferences. We showed that this training both improves the instruction following capability of the model, as well as its reward-modeling ability across the iterations. While there are many avenues left unexplored, we believe this is exciting because this means the model is better able to assign rewards in future iterations for improving instruction following - a kind of virtuous circle. While this improvement likely saturates in realistic scenarios, it still allows for the possibility of continual improvement beyond the human preferences that are typically used to build reward models and instruction following models today.\n\n## 6 Limitations\n\nWhile we have obtained promising experimental results, we currently consider them preliminary because there are many avenues yet to explore, among them the topics of further evaluation, including safety evaluation, and understanding the limits of iterative training.\n\nWe showed that the iterations of training improve both instruction following and reward modeling ability, but only ran three iterations in a single setting. A clear line of further research is to understand the 'scaling laws' of this effect both for more iterations, and with different language models with more or less capabilities in different settings.\n\nWe observed an increase in length in model generations, and there is a known correlation between length and estimated quality, which is a topic that should be understood more deeply in general, and in our results in particular as well. It would also be good to understand if so-called 'reward-hacking' can happen within our framework, and in what circumstances. As we are using both a language model as the training reward, and a language model for final evaluation (GPT-4) in some of our benchmarks, even if they are different models, this may require a deeper analysis than we have provided. While the human evaluation we conducted did provide validation of the automatic results, further study could bring more insights.\n\nAnother clear further avenue of study is to conduct safety evaluations - and to explore safety training within our framework. Reward models have been built exclusively for safety in existing systems [Touvron et al., 2023], and a promising avenue here would be to use the LLM-as-a-Judge procedure to evaluate for safety specifically in our self-rewarding training process. Given that we have shown that reward modeling ability improves over training iterations, this could mean that the safety of the model could potentially improve over time as well, with later iterations being able to catch and mitigate more challenging safety situations that earlier iterations cannot.\n\n## References\n\n- Josh Achiam, Steven Adler, Sandhini Agarwal, Lama Ahmad, Ilge Akkaya, Florencia Leoni Aleman, Diogo Almeida, Janko Altenschmidt, Sam Altman, Shyamal Anadkat, et al. GPT-4 technical report. arXiv preprint arXiv:2303.08774 , 2023.\n- Leonard Adolphs, Tianyu Gao, Jing Xu, Kurt Shuster, Sainbayar Sukhbaatar, and Jason Weston. The CRINGE loss: Learning what language not to model. In Anna Rogers, Jordan Boyd-Graber, and Naoaki Okazaki, editors, Proceedings of the 61st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers) , pages 8854-8874, Toronto, Canada, July 2023. Association for Computational Linguistics. doi: 10.18653/ v1/2023.acl-long.493. URL https://aclanthology.org/2023.acl-long.493 .\n- Anthropic. Claude 2. https://www.anthropic.com/index/claude-2 , 2023.\n- Yuntao Bai, Andy Jones, Kamal Ndousse, Amanda Askell, Anna Chen, Nova DasSarma, Dawn Drain, Stanislav Fort, Deep Ganguli, Tom Henighan, et al. Training a helpful and harmless assistant with reinforcement learning from human feedback. arXiv preprint arXiv:2204.05862 , 2022a.\n- Yuntao Bai, Saurav Kadavath, Sandipan Kundu, Amanda Askell, Jackson Kernion, Andy Jones, Anna Chen, Anna Goldie, Azalia Mirhoseini, Cameron McKinnon, et al. Constitutional AI: Harmlessness from AI feedback. arXiv preprint arXiv:2212.08073 , 2022b.\n- Yushi Bai, Jiahao Ying, Yixin Cao, Xin Lv, Yuze He, Xiaozhi Wang, Jifan Yu, Kaisheng Zeng, Yijia Xiao, Haozhe Lyu, Jiayin Zhang, Juanzi Li, and Lei Hou. Benchmarking foundation models with language-model-as-an-examiner. In Thirty-seventh Conference on Neural Information Processing Systems Datasets and Benchmarks Track , 2023. URL https://openreview.net/forum?id=IiRHQ7gvnq .\n- Yonatan Bisk, Rowan Zellers, Ronan Le Bras, Jianfeng Gao, and Yejin Choi. Piqa: Reasoning about physical commonsense in natural language. In Thirty-Fourth AAAI Conference on Artificial Intelligence , 2020.\n- Lichang Chen, Shiyang Li, Jun Yan, Hai Wang, Kalpa Gunaratna, Vikas Yadav, Zheng Tang, Vijay Srinivasan, Tianyi Zhou, Heng Huang, et al. AlpaGasus: Training a better alpaca with fewer data. In The Twelfth International Conference on Learning Representations , 2024a. URL https://openreview.net/forum?id=FdVXgSJhvz .\n- Zixiang Chen, Yihe Deng, Huizhuo Yuan, Kaixuan Ji, and Quanquan Gu. Self-play fine-tuning converts weak language models to strong language models. arXiv preprint arXiv:2401.01335 , 2024b.\n- Peter Clark, Isaac Cowhey, Oren Etzioni, Tushar Khot, Ashish Sabharwal, Carissa Schoenick, and Oyvind Tafjord. Think you have solved question answering? Try ARC, the AI2 reasoning challenge. arXiv preprint arXiv:1803.05457 , 2018.\n- Karl Cobbe, Vineet Kosaraju, Mohammad Bavarian, Mark Chen, Heewoo Jun, Lukasz Kaiser, Matthias Plappert, Jerry Tworek, Jacob Hilton, Reiichiro Nakano, Christopher Hesse, and John Schulman. Training verifiers to solve math word problems. arXiv preprint arXiv:2110.14168 , 2021.\n- Ronan Collobert and Jason Weston. A unified architecture for natural language processing: Deep neural networks with multitask learning. In Proceedings of the 25th International Conference on Machine Learning , pages 160-167, 2008.\n- Yann Dubois, Xuechen Li, Rohan Taori, Tianyi Zhang, Ishaan Gulrajani, Jimmy Ba, Carlos Guestrin, Percy Liang, and Tatsunori B Hashimoto. Alpacafarm: A simulation framework for methods that learn from human feedback. arXiv preprint arXiv:2305.14387 , 2023.\n- Patrick Fernandes, Daniel Deutsch, Mara Finkelstein, Parker Riley, André Martins, Graham Neubig, Ankush Garg, Jonathan Clark, Markus Freitag, and Orhan Firat. The devil is in the errors: Leveraging large language models for fine-grained machine translation evaluation.\n\nIn Philipp Koehn, Barry Haddow, Tom Kocmi, and Christof Monz, editors, Proceedings of the Eighth Conference on Machine Translation , pages 1066-1083, Singapore, December 2023. Association for Computational Linguistics. doi: 10.18653/v1/2023.wmt-1.100. URL https://aclanthology.org/2023.wmt-1.100 .\n\n- Caglar Gulcehre, Tom Le Paine, Srivatsan Srinivasan, Ksenia Konyushkova, Lotte Weerts, Abhishek Sharma, Aditya Siddhant, Alex Ahern, Miaosen Wang, Chenjie Gu, et al. Reinforced self-training (rest) for language modeling. arXiv preprint arXiv:2308.08998 , 2023.\n- Dan Hendrycks, Collin Burns, Steven Basart, Andy Zou, Mantas Mazeika, Dawn Song, and Jacob Steinhardt. Measuring massive multitask language understanding. In 9th International Conference on Learning Representations, ICLR 2021, Virtual Event, Austria, May 3-7, 2021 . OpenReview.net, 2021. URL https://openreview.net/forum?id=d7KBjmI3GmQ .\n- Or Honovich, Thomas Scialom, Omer Levy, and Timo Schick. Unnatural instructions: Tuning language models with (almost) no human labor. In Anna Rogers, Jordan Boyd-Graber, and Naoaki Okazaki, editors, Proceedings of the 61st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers) , pages 14409-14428, Toronto, Canada, July 2023. Association for Computational Linguistics. doi: 10.18653/v1/2023.acl-long.806. URL https://aclanthology.org/2023.acl-long.806 .\n- Seungone Kim, Jamin Shin, Yejin Cho, Joel Jang, Shayne Longpre, Hwaran Lee, Sangdoo Yun, Seongjin Shin, Sungdong Kim, James Thorne, et al. Prometheus: Inducing fine-grained evaluation capability in language models. arXiv preprint arXiv:2310.08491 , 2023.\n- Andreas Köpf, Yannic Kilcher, Dimitri von Rütte, Sotiris Anagnostidis, Zhi-Rui Tam, Keith Stevens, Abdullah Barhoum, Nguyen Minh Duc, Oliver Stanley, Richárd Nagyfi, et al. OpenAssistant conversations-democratizing large language model alignment. arXiv preprint arXiv:2304.07327 , 2023.\n- Tom Kwiatkowski, Jennimaria Palomaki, Olivia Redfield, Michael Collins, Ankur Parikh, Chris Alberti, Danielle Epstein, Illia Polosukhin, Matthew Kelcey, Jacob Devlin, Kenton Lee, Kristina N. Toutanova, Llion Jones, Ming-Wei Chang, Andrew Dai, Jakob Uszkoreit, Quoc Le, and Slav Petrov. Natural questions: a benchmark for question answering research. Transactions of the Association of Computational Linguistics , 2019.\n- Harrison Lee, Samrat Phatale, Hassan Mansoor, Kellie Lu, Thomas Mesnard, Colton Bishop, Victor Carbune, and Abhinav Rastogi. RLAIF: Scaling reinforcement learning from human feedback with ai feedback. arXiv preprint arXiv:2309.00267 , 2023.\n- Xian Li, Ping Yu, Chunting Zhou, Timo Schick, Luke Zettlemoyer, Omer Levy, Jason Weston, and Mike Lewis. Self-alignment with instruction backtranslation. In The Twelfth International Conference on Learning Representations , 2024. URL https://openreview. net/forum?id=1oijHJBRsT .\n- Xuechen Li, Tianyi Zhang, Yann Dubois, Rohan Taori, Ishaan Gulrajani, Carlos Guestrin, Percy Liang, and Tatsunori B. Hashimoto. Alpacaeval: An automatic evaluator of instruction-following models. https://github.com/tatsu-lab/alpaca\\_eval , 2023.\n- Chin-Yew Lin. ROUGE: A package for automatic evaluation of summaries. In Text Summarization Branches Out , pages 74-81, Barcelona, Spain, July 2004. Association for Computational Linguistics. URL https://aclanthology.org/W04-1013 .\n- Todor Mihaylov, Peter Clark, Tushar Khot, and Ashish Sabharwal. Can a suit of armor conduct electricity? a new dataset for open book question answering. In EMNLP , 2018.\n- Long Ouyang, Jeffrey Wu, Xu Jiang, Diogo Almeida, Carroll Wainwright, Pamela Mishkin, Chong Zhang, Sandhini Agarwal, Katarina Slama, Alex Ray, et al. Training language models to follow instructions with human feedback. Advances in Neural Information Processing Systems , 35:27730-27744, 2022.\n\n- Liangming Pan, Michael Saxon, Wenda Xu, Deepak Nathani, Xinyi Wang, and William Yang Wang. Automatically correcting large language models: Surveying the landscape of diverse self-correction strategies. arXiv preprint arXiv:2308.03188 , 2023.\n- Alec Radford, Jeffrey Wu, Rewon Child, David Luan, Dario Amodei, Ilya Sutskever, et al. Language models are unsupervised multitask learners. OpenAI blog , 1(8):9, 2019.\n- Rafael Rafailov, Archit Sharma, Eric Mitchell, Christopher D Manning, Stefano Ermon, and Chelsea Finn. Direct preference optimization: Your language model is secretly a reward model. In Thirty-seventh Conference on Neural Information Processing Systems , 2023. URL https://openreview.net/forum?id=HPuSIXJaa9 .\n- Swarnadeep Saha, Omer Levy, Asli Celikyilmaz, Mohit Bansal, Jason Weston, and Xian Li. Branch-solve-merge improves large language model evaluation and generation. arXiv preprint arXiv:2310.15123 , 2023.\n- Maarten Sap, Hannah Rashkin, Derek Chen, Ronan Le Bras, and Yejin Choi. Socialiqa: Commonsense reasoning about social interactions. CoRR , abs/1904.09728, 2019. URL http://arxiv.org/abs/1904.09728 .\n- John Schulman, Filip Wolski, Prafulla Dhariwal, Alec Radford, and Oleg Klimov. Proximal policy optimization algorithms. arXiv preprint arXiv:1707.06347 , 2017.\n- Nisan Stiennon, Long Ouyang, Jeffrey Wu, Daniel Ziegler, Ryan Lowe, Chelsea Voss, Alec Radford, Dario Amodei, and Paul F Christiano. Learning to summarize with human feedback. Advances in Neural Information Processing Systems , 33:3008-3021, 2020.\n- Rohan Taori, Ishaan Gulrajani, Tianyi Zhang, Yann Dubois, Xuechen Li, Carlos Guestrin, Percy Liang, and Tatsunori B. Hashimoto. Stanford alpaca: An instruction-following llama model. https://github.com/tatsu-lab/stanford\\_alpaca , 2023.\n- Hugo Touvron, Louis Martin, Kevin Stone, Peter Albert, Amjad Almahairi, Yasmine Babaei, Nikolay Bashlykov, Soumya Batra, Prajjwal Bhargava, Shruti Bhosale, et al. Llama 2: Open foundation and fine-tuned chat models. arXiv preprint arXiv:2307.09288 , 2023.\n- Laurens Van der Maaten and Geoffrey Hinton. Visualizing data using t-SNE. Journal of machine learning research , 9(11), 2008.\n- Yizhong Wang, Yeganeh Kordi, Swaroop Mishra, Alisa Liu, Noah A. Smith, Daniel Khashabi, and Hannaneh Hajishirzi. Self-instruct: Aligning language models with selfgenerated instructions. In Anna Rogers, Jordan Boyd-Graber, and Naoaki Okazaki, editors, Proceedings of the 61st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers) , pages 13484-13508, Toronto, Canada, July 2023. Association for Computational Linguistics. doi: 10.18653/v1/2023.acl-long.754. URL https://aclanthology.org/2023.acl-long.754 .\n- Wei Xiong, Hanze Dong, Chenlu Ye, Han Zhong, Nan Jiang, and Tong Zhang. Gibbs sampling from human feedback: A provable kl-constrained framework for rlhf. arXiv preprint arXiv:2312.11456 , 2023.\n- Jing Xu, Andrew Lee, Sainbayar Sukhbaatar, and Jason Weston. Some things are more cringe than others: Preference optimization with the pairwise cringe loss. arXiv preprint arXiv:2312.16682 , 2023.\n- Hongyi Yuan, Zheng Yuan, Chuanqi Tan, Wei Wang, Songfang Huang, and Fei Huang. RRHF: Rank responses to align language models with human feedback. In Thirty-seventh Conference on Neural Information Processing Systems , 2023. URL https://openreview. net/forum?id=EdIGMCHk4l .\n- Rowan Zellers, Ari Holtzman, Yonatan Bisk, Ali Farhadi, and Yejin Choi. Hellaswag: Can a machine really finish your sentence? In Anna Korhonen, David R. Traum, and Lluís Màrquez, editors, Proceedings of the 57th Conference of the Association for Computational Linguistics, ACL 2019, Florence, Italy, July 28- August 2, 2019, Volume 1: Long Papers , pages 4791-4800. Association for Computational Linguistics, 2019. doi: 10.18653/V1/ P19-1472. URL https://doi.org/10.18653/v1/p19-1472 .\n\n- Yao Zhao, Rishabh Joshi, Tianqi Liu, Misha Khalman, Mohammad Saleh, and Peter J Liu. SLiC-HF: Sequence likelihood calibration with human feedback. arXiv preprint arXiv:2305.10425 , 2023.\n- Chujie Zheng, Pei Ke, Zheng Zhang, and Minlie Huang. Click: Controllable text generation with sequence likelihood contrastive learning. In Anna Rogers, Jordan Boyd-Graber, and Naoaki Okazaki, editors, Findings of the Association for Computational Linguistics: ACL 2023 , pages 1022-1040, Toronto, Canada, July 2023a. Association for Computational Linguistics. doi: 10.18653/v1/2023.findings-acl.65. URL https://aclanthology.org/ 2023.findings-acl.65 .\n- Lianmin Zheng, Wei-Lin Chiang, Ying Sheng, Siyuan Zhuang, Zhanghao Wu, Yonghao Zhuang, Zi Lin, Zhuohan Li, Dacheng Li, Eric Xing, Hao Zhang, Joseph E. Gonzalez, and Ion Stoica. Judging LLM-as-a-judge with MT-bench and chatbot arena. In Thirty-seventh Conference on Neural Information Processing Systems Datasets and Benchmarks Track , 2023b. URL https://openreview.net/forum?id=uccHPGDlao .\n- Daniel M Ziegler, Nisan Stiennon, Jeffrey Wu, Tom B Brown, Alec Radford, Dario Amodei, Paul Christiano, and Geoffrey Irving. Fine-tuning language models from human preferences. arXiv preprint arXiv:1909.08593 , 2019.\n\n## A Appendix\n\n## A.1 Distributions of IFT, EFT and AIFT data\n\n(a) Instruction distribution of IFT, EFT and AIFT data. (b) Response distribution of IFT, EFT, and AIFT data.\n\n<!-- image -->\n\nFigure 6: Distributions of both instructions and responses for IFT, EFT and AIFT data.\n\nWe have plotted the distribution of instructions for IFT, EFT and AIFT( M 1 ) data, and the distribution of responses for IFT, EFT and AIFT( M 1 ) data in Figure 6. It is clear that the IFT data and EFT data come from very different distributions while the IFT and AIFT( M 1 ) data come from similar distributions.\n\n## A.2 EFT Prompts\n\nThe EFT prompt which we use in our main experiments is shown in Figure 2.\n\nOther EFT prompts we have tried At first, we took the EFT prompt from Li et al. [2024] as shown in Figure 7. However, we found that this prompt was not as effective as our additive score-counting prompt because the model needed to treat the task as a multiple-choice problem, and it was difficult for the model to break down this multiple-choice problem into sub-problems involving evaluating various aspects of the response. When using the model trained on 3,200 IFT data only, its performance on the EFT test set using our additive score-counting prompt and prompt from Li et al. [2024] is shown in Table 5.\n\nTable 5: We tried various LLM-as-Judge prompts using the model trained with 3,200 IFT data only and found that our additive score-counting prompt worked best which demonstrates significant improvements in EFT performance comparing to the prompt used by Li et al. [2024].\n\n| EFT Prompt              | Multiple Choice prompt   | Ours   |\n|-------------------------|--------------------------|--------|\n| Pairwise accuracy ( ↑ ) | 26.6%                    | 65.1%  |\n| 5-best % ( ↑ )          | 23.5%                    | 39.6%  |\n| Exact Match % ( ↑ )     | 1.1%                     | 10.1%  |\n| Spearman corr. ( ↑ )    | -0.18                    | 0.25   |\n| Kendall τ corr. ( ↑ )   | -0.16                    | 0.23   |\n\n## A.3 Self-rewarding Models Using IFT Data Only\n\nTo demonstrate the importance of the EFT data, we also trained a series of models starting with the model trained only on the IFT data. The following is the model sequence.\n\nM 0 : Base pretrained LLM with no fine-tuning.\n\nBelow is a question from an user and a candidate response. Please grade the response on a 5-point scale using the following criteria:\n\n1: It means the answer is incomplete, vague, off-topic, controversial, or not exactly what the user asked for. For example, some content seems missing, numbered list does not start from the beginning, the opening sentence repeats user's question. Or the response is from another person's perspective with their personal experience (e.g. taken from blog posts), or looks like an answer from a forum. Or it contains promotional text, navigation text, or other irrelevant information.\n\n2: It means the answer addresses most of the asks from the user. It does not directly address the user's question. For example, it only provides a high-level methodology instead of the exact solution to user's question.\n\n3: It means the answer is helpful but not written by an AI Assistant. It addresses all the basic asks from the user. It is complete and self contained with the drawback that the response is not written from an AI assistant's perspective, but from other people's perspective. The content looks like an excerpt from a blog post, web page, or web search results. For example, it contains personal experience or opinion, mentions comments section, or share on social media, etc.\n\n4: It means the answer is written from an AI assistant's perspective with a clear focus of addressing the instruction. It provide a complete, clear, and comprehensive response to user's question or instruction without missing or irrelevant information. It is well organized, self-contained, and written in a helpful tone. It has minor room for improvement, e.g. more concise and focused.\n\n5: It means it is a perfect answer from an AI Assistant. It has a clear focus on being a helpful AI Assistant, where the response looks like intentionally written to address the user's question or instruction without any irrelevant sentences. The answer provides high quality content, demonstrating expert knowledge in the area, is very well written, logical, easy-to-follow, engaging and insightful.\n\nUser:\n\n```\n<INSTRUCTION_HERE>\n```\n\n&lt; response &gt;&lt;RESPONSE\\_HERE&gt;&lt; /response &gt;\n\nPlease first briefly describe your reasoning (in less than 100 words), and then write 'Score: &lt; rating &gt; ' in the last line. Answer in the style of an AI Assistant, with knowledge from web search if needed. To derive the final score based on the criteria, let's think step-by-step.\n\nFigure 7: LLM-as-a-Judge prompt taken from Li et al. [2024].\n\nM ′ 1 : Initialized with M 0 , then fine-tuned on the IFT seed data only using SFT.\n\nM ′ 2 : Initialized with M ′ 1 , then trained with AIFT( M ′ 1 ) data using DPO.\n\nM ′ 3 : Initialized with M ′ 2 , then trained with AIFT( M ′ 2 ) data using DPO.\n\nSince we did not use EFT data to train the series of models, they were not always able to score the responses according to the format and even when they did, the scores given typically converged to 4. Therefore, even when starting from the same number of generated new prompts, we could only collect a very small number of valid training samples for DPO. In total, we collected 541 pairs to form the AIFT( M ′ 1 ) dataset used to train M ′ 2 via DPO, and 429 pairs to form AIFT( M ′ 2 ) used to train M ′ 3 . The win rates are shown in Figure 8. From the figure we can conclude that EFT data helps to get better performance in the same number of iterations and the gap in performance between the model trained with EFT data and the model trained without EFT data widens in the later iterations.\n\n<!-- image -->\n\n2\n\nFigure 8: EFT data helps the self-rewarding loop: We evaluated the series of models trained using self-reward loops starting from the model trained using only IFT data. We performed head-to-head win rates comparisons on the IFT test set. While M ′ 2 can improve over the SFT baseline and M ′ 3 can improve even more over the SFT baseline, they lag far behind the corresponding models ( M 2 , M 3 ) that started from a base model trained using both IFT and EFT data, see Figure 3.\n\n## &lt;LIST ALL ALPACAEVAL INSTRUCTIONS&gt;\n\nGiven the above list of possible instructions, define a maximum of 20 categories that would cover the types of intructions, for example recipes, reasoning tasks, general knowledge etc. Try to cover as many of the instructions as possible with the maximum 20 categories, while keeping the categories high-level, simple and easy to understand.\n\nFigure 9: Prompt used to obtain instruction categories on the AlpacaEval test set.\n\nInstruction:\n\n&lt;INSTRUCTION&gt;\n\nGiven the above, categorize it into one of the following 20 categories:\n\n&lt;LIST ALL CATEGORIES&gt;\n\nSecondly, score the instruction in terms of complexity: how complex you think it is to answer from 1-10 (where 10 is a complex question whereby first reasoning or breaking down the question into multiple subquestions for example might help improve the answer).\n\nThirdly, indicate how long you think the response to the instruction should be, either (a) 1 sentence, (b) 1-3 sentences, (c) 1 paragraph, (d) 2 paragraphs, or (e) 3 or more paragraphs.\n\nProvide your final response in the following format:\n\nCategory:\n\n&lt; one of the 20 categories &gt;\n\nComplexity:\n\n&lt; score out of 10 &gt;\n\nLength:\n\n&lt; length category &gt; . Do not provide the actual response.\n\nFigure 10: Prompt for categorizing instructions based on their topics, complexities and expected response lengths.\n\nTable 6: Breakdown of AlpacaEval test set instructions by instruction category.\n\n| Category                                            |   Number | Percentage   |\n|-----------------------------------------------------|----------|--------------|\n| Science / Technology / Engineering                  |      134 | 16.65%       |\n| Professional / Business / Marketing                 |       77 | 9.57%        |\n| Social Interaction / Relationships / Human Behavior |       68 | 8.45%        |\n| Miscellaneous / Other                               |       61 | 7.58%        |\n| Mathematics / Logical Reasoning                     |       52 | 6.46%        |\n| Cooking / Recipes                                   |       48 | 5.96%        |\n| Software Development / Coding / Algorithms          |       44 | 5.47%        |\n| Travel / Geography / Exploration                    |       41 | 5.09%        |\n| Literature / Writing / Communication                |       39 | 4.84%        |\n| History / Social Studies                            |       38 | 4.72%        |\n| Entertainment / Media Analysis                      |       34 | 4.22%        |\n| Language Learning / Linguistics                     |       32 | 3.98%        |\n| Music / Audio / Arts                                |       30 | 3.73%        |\n| DIY Projects / Hobbies                              |       24 | 2.98%        |\n| Technology / Gadgets / Consumer Products            |       20 | 2.48%        |\n| Gaming / Game Development                           |       18 | 2.24%        |\n| Exercise / Health / Wellness                        |       16 | 1.99%        |\n| Philosophy / Ethics / Ideology                      |       15 | 1.86%        |\n| Sports / Athletics / Physical Activity              |       12 | 1.49%        |\n| Strategy / Problem-Solving / Critical Thinking      |        2 | 0.24%        |\n\nTable 7: Breakdown of AlpacaEval test set instructions by instruction complexity. The instructions increase in complexity from 1 to 9, where 10 is a complex question that requires first reasoning or breaking the problem into sub-problems before it can be solved.\n\nFigure 11: AlpacaEval win rate breakdown for instruction complexities (left) and expected response lengths (right). Self-Rewarding models give gains across most complexities and all response length ranges.\n\n|   Complexity |   Number | Percentage   |\n|--------------|----------|--------------|\n|            3 |      238 | 29.57%       |\n|            2 |      206 | 25.59%       |\n|            4 |      122 | 15.16%       |\n|            6 |       79 | 9.81%        |\n|            5 |       68 | 8.45%        |\n|            7 |       41 | 5.09%        |\n|            1 |       34 | 4.22%        |\n|            8 |       14 | 1.74%        |\n|            9 |        3 | 0.37%        |\n\n<!-- image -->\n\nTable 8: Breakdown of AlpacaEval test set instructions by expected response length.\n\n| Expected Length      |   Number | Percentage   |\n|----------------------|----------|--------------|\n| 1-3 sentences        |      361 | 44.84%       |\n| 1 paragraph          |      269 | 33.42%       |\n| 1 sentence           |      143 | 17.76%       |\n| 2 paragraphs         |       31 | 3.85%        |\n| 3 or more paragraphs |        1 | 0.13%        |\n\n## A.4 Preference optimization outperforms augmenting with positive examples only\n\nWe also tried an alternative self-training procedure of adding high-quality self-instruction creation examples to supervised fine-tuning (without preference optimization), rather than DPO. In this variant, we add additional examples of (instruction prompt, response) curated by the model to the seed set for supervised fine-tuning, following other approaches [Li et al., 2024, Adolphs et al., 2023, Gulcehre et al., 2023], rather than constructing preference data. In this setup we only add examples where the candidate response was evaluated to give a perfect score of r n i = 5. Unfortunately we could not find a configuration where this approach helped. For example, adding 11,254 such examples that scored 5 out of 5, and optimizing the mixing weight in training, still yielded a head to head with the SFT Baseline of 29% wins vs 30% wins, i.e., no improvement.\n\n## A.5 Augmented Prompt Generation Using Newly Trained Models\n\nIn our experiments, for time efficiency, we have created a fixed pool of augmented prompts in advance using ChatLlama 70B. In a real interactive system, ideally, those prompts could come from real users so that we can ensure the models are trained to align with real user requirements. Here, we also examine whether our newly trained Self-Rewarding models in each iteration can generate new prompts through in-context learning, instead of using ChatLlama 70B. To check this, we constructed 30 prompts with in-context examples using the original seed IFT data as described in Section 2.2 and tested whether M 1 , M 2 and M 3 still possess in-context learning ability and can generate high quality instructions. According to manual inspection, all models can generate novel instructions given in-context examples in all 30 cases. However, for M 2 and M 3, the model is likely to first generate a few instructions, then generate a separator, and then start responding to the instructions, so some postprocessing might be necessary.\n\n## A.6 AlpacaEval Test Sample Clustering\n\nWe used the GPT-4 ( gpt-4-1106-preview ) model to categorize the instructions in the AlpacaEval test set into clusters from three perspectives: (1) instruction category, (2) instruction complexity, and (3) expected response length. To obtain instruction categories for the AlpaceEval test set, we used the prompt in Figure 9 and obtained 20 categories in total. Then, to cluster the instructions into different groups, we use the prompt in Figure 10 for each test example. The corresponding statistics are given in Table 6, Table 7, Table 8. The fine-grained results on instruction complexity and expected response length are given in Figure 11.\n\nTable 9: NLP Benchmarks . Self-Rewarding models mostly tend to maintain performance compared to the Llama 2 base model and the SFT Baseline, despite being fine-tuned on very different instruction-following prompts.\n\n|              | Commonsense Reasoning   | Commonsense Reasoning   | Commonsense Reasoning   | Commonsense Reasoning   | Commonsense Reasoning   | Math       | World Knowledge      | World Knowledge   | World Knowledge   |\n|--------------|-------------------------|-------------------------|-------------------------|-------------------------|-------------------------|------------|----------------------|-------------------|-------------------|\n|              | ARC easy                | ARC challenge           | HellaSwag               | SIQA                    | PIQA                    | GSM8K (em) | MMLU (macro_avg/acc) | OBQA (acc_comp)   | NQ (em)           |\n| Llama 2      | 80.20                   | 57.40                   | 85.30                   | 50.70                   | 82.80                   | 56.80      | 68.90                | 60.20             | 25.30             |\n| SFT Baseline | 76.49                   | 55.97                   | 85.17                   | 51.48                   | 82.59                   | 50.72      | 69.76                | 57.80             | 34.35             |\n| M 1          | 78.14                   | 57.51                   | 84.99                   | 53.02                   | 82.92                   | 60.27      | 69.34                | 57.60             | 35.48             |\n| M 2          | 74.84                   | 54.51                   | 84.27                   | 51.23                   | 81.94                   | 59.29      | 69.31                | 57.60             | 33.07             |\n| M 3          | 72.35                   | 53.13                   | 83.29                   | 49.28                   | 80.79                   | 57.70      | 69.37                | 58.40             | 31.86             |\n\nTable 10: MT-Bench Fine-grained Results . We list our models' performance on each problem category. Self-reward is especially effective in improving the model's ability in writing, role-playing, extraction, and STEM tasks.\n\n|     |   Writing |   Roleplay |   Reasoning |   Math |   Coding |   Extraction |   STEM |   Humanities |   Overall |\n|-----|-----------|------------|-------------|--------|----------|--------------|--------|--------------|-----------|\n| SFT |      8.83 |       8.15 |        5.3  |   3    |     3.5  |         6.9  |   9.18 |         9.95 |      6.85 |\n| M1  |      9.1  |       7.65 |        4.35 |   3.05 |     4.1  |         7.2  |   8.93 |         9.85 |      6.78 |\n| M2  |      9.1  |       8    |        4.6  |   3.3  |     4.25 |         7.65 |   9.4  |         9.8  |      7.01 |\n| M3  |      9.58 |       8.73 |        4.8  |   3.5  |     4.2  |         7.8  |   9.45 |         9.95 |      7.25 |\n\n## A.7 NLP Benchmark Results and MT-Bench Results\n\nWe provide the detailed model performance on a number of NLP benchmarks in Table 9 and on MT-Bench in Table 10. In particular, some NLP benchmarks including ARC-Challenge, HellaSwag, SIQA, PIQA, and OBQA are all text completion tasks. In these tasks, given the multiple choice options, we choose the option corresponding to the highest log probability scored by the models as the final answer. As such, the objective of these particular tasks is quite different from what our algorithm tries to optimize, so the results on these tasks may not reflect the true capability of our models.",
  "tables": [
    {
      "index": 0,
      "markdown": "|                                                 |          | Alignment Targets   | Alignment Targets   |\n|-------------------------------------------------|----------|---------------------|---------------------|\n| Model                                           | Win Rate | Distilled           | Proprietary         |\n| Self-Rewarding 70B                              |          |                     |                     |\n| Iteration 1 ( M 1 )                             | 9.94%    |                     |                     |\n| Iteration 2 ( M 2 )                             | 15.38%   |                     |                     |\n| Iteration 3 ( M 3 )                             | 20.44%   |                     |                     |\n| Selected models from the leaderboard GPT-4 0314 | 22.07%   |                     | ✓                   |\n| Mistral Medium                                  | 21.86%   |                     | ✓                   |\n| Claude 2                                        | 17.19%   |                     | ✓                   |\n| Gemini Pro                                      | 16.85%   |                     | ✓                   |\n| GPT-4 0613                                      | 15.76%   |                     | ✓                   |\n| GPT 3.5 Turbo 0613                              | 14.13%   |                     | ✓                   |\n| LLaMA2 Chat 70B                                 | 13.87%   |                     | ✓                   |\n| Vicuna 33B v1.3                                 | 12.71%   | ✓                   |                     |\n| Humpback LLaMa2 70B                             | 10.12%   |                     |                     |\n| Guanaco 65B                                     | 6.86%    |                     |                     |\n| Davinci001                                      | 2.76%    |                     | ✓                   |\n| Alpaca 7B                                       | 2.59%    | ✓                   |                     |"
    },
    {
      "index": 1,
      "markdown": "|              |   Overall Score |   Math, Code & Reasoning |   Humanities, Extraction, STEM, Roleplay & Writing |\n|--------------|-----------------|--------------------------|----------------------------------------------------|\n| SFT Baseline |            6.85 |                     3.93 |                                               8.6  |\n| M 1          |            6.78 |                     3.83 |                                               8.55 |\n| M 2          |            7.01 |                     4.05 |                                               8.79 |\n| M 3          |            7.25 |                     4.17 |                                               9.1  |"
    },
    {
      "index": 2,
      "markdown": "|              |   ARC ( ↑ ) challenge |   HellaSwag ( ↑ ) |   GSM8K ( ↑ ) |   MMLU ( ↑ ) |   NQ ( ↑ ) |\n|--------------|-----------------------|-------------------|---------------|--------------|------------|\n| Llama 2      |                 57.4  |             85.3  |         56.8  |        68.9  |      25.3  |\n| SFT Baseline |                 55.97 |             85.17 |         50.72 |        69.76 |      34.35 |\n| M 1          |                 57.51 |             84.99 |         60.27 |        69.34 |      35.48 |\n| M 2          |                 54.51 |             84.27 |         59.29 |        69.31 |      33.07 |\n| M 3          |                 53.13 |             83.29 |         57.7  |        69.37 |      31.86 |"
    },
    {
      "index": 3,
      "markdown": "|                       |              | Self-Rewarding Models   | Self-Rewarding Models   | Self-Rewarding Models            |\n|-----------------------|--------------|-------------------------|-------------------------|----------------------------------|\n| Model                 | SFT Baseline | Iter 1 ( M 1 )          | Iter 2 ( M 2 )          | Iter 3 ( M 3 )                   |\n| Training data         | IFT          | IFT+EFT                 | IFT+EFT +AIFT( M 1 )    | IFT+EFT+AIFT( M 1 ) +AIFT( M 2 ) |\n| Pairwise acc. ( ↑ )   | 65.1%        | 78.7%                   | 80.4%                   | 81.7%                            |\n| 5-best % ( ↑ )        | 39.6%        | 41.5%                   | 44.3%                   | 43.2%                            |\n| Exact Match % ( ↑     | 10.1%        | 13.1%                   | 14.3%                   | 14.3%                            |\n| Spearman corr. ( ↑ )  | 0.253        | 0.279                   | 0.331                   | 0.349                            |\n| Kendall τ corr. ( ↑ ) | 0.233        | 0.253                   | 0.315                   | 0.324                            |"
    },
    {
      "index": 4,
      "markdown": "| EFT Prompt              | Multiple Choice prompt   | Ours   |\n|-------------------------|--------------------------|--------|\n| Pairwise accuracy ( ↑ ) | 26.6%                    | 65.1%  |\n| 5-best % ( ↑ )          | 23.5%                    | 39.6%  |\n| Exact Match % ( ↑ )     | 1.1%                     | 10.1%  |\n| Spearman corr. ( ↑ )    | -0.18                    | 0.25   |\n| Kendall τ corr. ( ↑ )   | -0.16                    | 0.23   |"
    },
    {
      "index": 5,
      "markdown": "| Category                                            |   Number | Percentage   |\n|-----------------------------------------------------|----------|--------------|\n| Science / Technology / Engineering                  |      134 | 16.65%       |\n| Professional / Business / Marketing                 |       77 | 9.57%        |\n| Social Interaction / Relationships / Human Behavior |       68 | 8.45%        |\n| Miscellaneous / Other                               |       61 | 7.58%        |\n| Mathematics / Logical Reasoning                     |       52 | 6.46%        |\n| Cooking / Recipes                                   |       48 | 5.96%        |\n| Software Development / Coding / Algorithms          |       44 | 5.47%        |\n| Travel / Geography / Exploration                    |       41 | 5.09%        |\n| Literature / Writing / Communication                |       39 | 4.84%        |\n| History / Social Studies                            |       38 | 4.72%        |\n| Entertainment / Media Analysis                      |       34 | 4.22%        |\n| Language Learning / Linguistics                     |       32 | 3.98%        |\n| Music / Audio / Arts                                |       30 | 3.73%        |\n| DIY Projects / Hobbies                              |       24 | 2.98%        |\n| Technology / Gadgets / Consumer Products            |       20 | 2.48%        |\n| Gaming / Game Development                           |       18 | 2.24%        |\n| Exercise / Health / Wellness                        |       16 | 1.99%        |\n| Philosophy / Ethics / Ideology                      |       15 | 1.86%        |\n| Sports / Athletics / Physical Activity              |       12 | 1.49%        |\n| Strategy / Problem-Solving / Critical Thinking      |        2 | 0.24%        |"
    },
    {
      "index": 6,
      "markdown": "|   Complexity |   Number | Percentage   |\n|--------------|----------|--------------|\n|            3 |      238 | 29.57%       |\n|            2 |      206 | 25.59%       |\n|            4 |      122 | 15.16%       |\n|            6 |       79 | 9.81%        |\n|            5 |       68 | 8.45%        |\n|            7 |       41 | 5.09%        |\n|            1 |       34 | 4.22%        |\n|            8 |       14 | 1.74%        |\n|            9 |        3 | 0.37%        |"
    },
    {
      "index": 7,
      "markdown": "| Expected Length      |   Number | Percentage   |\n|----------------------|----------|--------------|\n| 1-3 sentences        |      361 | 44.84%       |\n| 1 paragraph          |      269 | 33.42%       |\n| 1 sentence           |      143 | 17.76%       |\n| 2 paragraphs         |       31 | 3.85%        |\n| 3 or more paragraphs |        1 | 0.13%        |"
    },
    {
      "index": 8,
      "markdown": "|              | Commonsense Reasoning   | Commonsense Reasoning   | Commonsense Reasoning   | Commonsense Reasoning   | Commonsense Reasoning   | Math       | World Knowledge      | World Knowledge   | World Knowledge   |\n|--------------|-------------------------|-------------------------|-------------------------|-------------------------|-------------------------|------------|----------------------|-------------------|-------------------|\n|              | ARC easy                | ARC challenge           | HellaSwag               | SIQA                    | PIQA                    | GSM8K (em) | MMLU (macro_avg/acc) | OBQA (acc_comp)   | NQ (em)           |\n| Llama 2      | 80.20                   | 57.40                   | 85.30                   | 50.70                   | 82.80                   | 56.80      | 68.90                | 60.20             | 25.30             |\n| SFT Baseline | 76.49                   | 55.97                   | 85.17                   | 51.48                   | 82.59                   | 50.72      | 69.76                | 57.80             | 34.35             |\n| M 1          | 78.14                   | 57.51                   | 84.99                   | 53.02                   | 82.92                   | 60.27      | 69.34                | 57.60             | 35.48             |\n| M 2          | 74.84                   | 54.51                   | 84.27                   | 51.23                   | 81.94                   | 59.29      | 69.31                | 57.60             | 33.07             |\n| M 3          | 72.35                   | 53.13                   | 83.29                   | 49.28                   | 80.79                   | 57.70      | 69.37                | 58.40             | 31.86             |"
    },
    {
      "index": 9,
      "markdown": "|     |   Writing |   Roleplay |   Reasoning |   Math |   Coding |   Extraction |   STEM |   Humanities |   Overall |\n|-----|-----------|------------|-------------|--------|----------|--------------|--------|--------------|-----------|\n| SFT |      8.83 |       8.15 |        5.3  |   3    |     3.5  |         6.9  |   9.18 |         9.95 |      6.85 |\n| M1  |      9.1  |       7.65 |        4.35 |   3.05 |     4.1  |         7.2  |   8.93 |         9.85 |      6.78 |\n| M2  |      9.1  |       8    |        4.6  |   3.3  |     4.25 |         7.65 |   9.4  |         9.8  |      7.01 |\n| M3  |      9.58 |       8.73 |        4.8  |   3.5  |     4.2  |         7.8  |   9.45 |         9.95 |      7.25 |"
    }
  ],
  "stats": {
    "pages": 23,
    "chunksCreated": 107,
    "totalCharacters": 73928,
    "totalWords": 11193,
    "numTables": 10,
    "processingTimeMs": 34139
  }
}